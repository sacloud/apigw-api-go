// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAddCertificateBadRequest_EncodeDecode(t *testing.T) {
	var typ AddCertificateBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddCertificateBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddCertificateConflict_EncodeDecode(t *testing.T) {
	var typ AddCertificateConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddCertificateConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddCertificateCreated_EncodeDecode(t *testing.T) {
	var typ AddCertificateCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddCertificateCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddCertificateCreatedApigw_EncodeDecode(t *testing.T) {
	var typ AddCertificateCreatedApigw
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddCertificateCreatedApigw
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddCertificateInternalServerError_EncodeDecode(t *testing.T) {
	var typ AddCertificateInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddCertificateInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddCertificateUnauthorized_EncodeDecode(t *testing.T) {
	var typ AddCertificateUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddCertificateUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddCertificateUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ AddCertificateUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddCertificateUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddDomainBadRequest_EncodeDecode(t *testing.T) {
	var typ AddDomainBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddDomainBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddDomainConflict_EncodeDecode(t *testing.T) {
	var typ AddDomainConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddDomainConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddDomainCreated_EncodeDecode(t *testing.T) {
	var typ AddDomainCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddDomainCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddDomainCreatedApigw_EncodeDecode(t *testing.T) {
	var typ AddDomainCreatedApigw
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddDomainCreatedApigw
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddDomainInternalServerError_EncodeDecode(t *testing.T) {
	var typ AddDomainInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddDomainInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddDomainUnauthorized_EncodeDecode(t *testing.T) {
	var typ AddDomainUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddDomainUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddGroupBadRequest_EncodeDecode(t *testing.T) {
	var typ AddGroupBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddGroupBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddGroupConflict_EncodeDecode(t *testing.T) {
	var typ AddGroupConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddGroupConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddGroupCreated_EncodeDecode(t *testing.T) {
	var typ AddGroupCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddGroupCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddGroupCreatedApigw_EncodeDecode(t *testing.T) {
	var typ AddGroupCreatedApigw
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddGroupCreatedApigw
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddGroupInternalServerError_EncodeDecode(t *testing.T) {
	var typ AddGroupInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddGroupInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddGroupUnauthorized_EncodeDecode(t *testing.T) {
	var typ AddGroupUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddGroupUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddOidcBadRequest_EncodeDecode(t *testing.T) {
	var typ AddOidcBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddOidcBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddOidcConflict_EncodeDecode(t *testing.T) {
	var typ AddOidcConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddOidcConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddOidcCreated_EncodeDecode(t *testing.T) {
	var typ AddOidcCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddOidcCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddOidcCreatedApigw_EncodeDecode(t *testing.T) {
	var typ AddOidcCreatedApigw
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddOidcCreatedApigw
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddOidcInternalServerError_EncodeDecode(t *testing.T) {
	var typ AddOidcInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddOidcInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddOidcNotFound_EncodeDecode(t *testing.T) {
	var typ AddOidcNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddOidcNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddOidcUnauthorized_EncodeDecode(t *testing.T) {
	var typ AddOidcUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddOidcUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddOidcUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ AddOidcUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddOidcUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddRouteBadRequest_EncodeDecode(t *testing.T) {
	var typ AddRouteBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRouteBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddRouteConflict_EncodeDecode(t *testing.T) {
	var typ AddRouteConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRouteConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddRouteCreated_EncodeDecode(t *testing.T) {
	var typ AddRouteCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRouteCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddRouteInternalServerError_EncodeDecode(t *testing.T) {
	var typ AddRouteInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRouteInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddRouteNotFound_EncodeDecode(t *testing.T) {
	var typ AddRouteNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRouteNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddRouteUnauthorized_EncodeDecode(t *testing.T) {
	var typ AddRouteUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddRouteUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddServiceBadRequest_EncodeDecode(t *testing.T) {
	var typ AddServiceBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddServiceBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddServiceConflict_EncodeDecode(t *testing.T) {
	var typ AddServiceConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddServiceConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddServiceInternalServerError_EncodeDecode(t *testing.T) {
	var typ AddServiceInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddServiceInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddServiceNotFound_EncodeDecode(t *testing.T) {
	var typ AddServiceNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddServiceNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddServiceOK_EncodeDecode(t *testing.T) {
	var typ AddServiceOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddServiceOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddServiceOKApigw_EncodeDecode(t *testing.T) {
	var typ AddServiceOKApigw
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddServiceOKApigw
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddServiceUnauthorized_EncodeDecode(t *testing.T) {
	var typ AddServiceUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddServiceUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddServiceUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ AddServiceUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddServiceUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddUserBadRequest_EncodeDecode(t *testing.T) {
	var typ AddUserBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddUserBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddUserConflict_EncodeDecode(t *testing.T) {
	var typ AddUserConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddUserConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddUserCreated_EncodeDecode(t *testing.T) {
	var typ AddUserCreated
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddUserCreated
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddUserCreatedApigw_EncodeDecode(t *testing.T) {
	var typ AddUserCreatedApigw
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddUserCreatedApigw
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddUserInternalServerError_EncodeDecode(t *testing.T) {
	var typ AddUserInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddUserInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthenticationMethods_EncodeDecode(t *testing.T) {
	var typ AuthenticationMethods
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthenticationMethods
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthenticationMethodsItem_EncodeDecode(t *testing.T) {
	var typ AuthenticationMethodsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthenticationMethodsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAuthenticationMethodsItem_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"accessToken\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AuthenticationMethodsItem

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AuthenticationMethodsItem
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestBasicAuth_EncodeDecode(t *testing.T) {
	var typ BasicAuth
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BasicAuth
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCertificate_EncodeDecode(t *testing.T) {
	var typ Certificate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Certificate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCertificateDetails_EncodeDecode(t *testing.T) {
	var typ CertificateDetails
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CertificateDetails
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCertificateBadRequest_EncodeDecode(t *testing.T) {
	var typ DeleteCertificateBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCertificateBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCertificateInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteCertificateInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCertificateInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCertificateNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteCertificateNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCertificateNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteCertificateUnauthorized_EncodeDecode(t *testing.T) {
	var typ DeleteCertificateUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteCertificateUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteDomainBadRequest_EncodeDecode(t *testing.T) {
	var typ DeleteDomainBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteDomainBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteDomainInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteDomainInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteDomainInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteDomainNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteDomainNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteDomainNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteDomainUnauthorized_EncodeDecode(t *testing.T) {
	var typ DeleteDomainUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteDomainUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteGroupBadRequest_EncodeDecode(t *testing.T) {
	var typ DeleteGroupBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteGroupBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteGroupInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteGroupInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteGroupInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteGroupNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteGroupNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteGroupNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteGroupUnauthorized_EncodeDecode(t *testing.T) {
	var typ DeleteGroupUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteGroupUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteOidcBadRequest_EncodeDecode(t *testing.T) {
	var typ DeleteOidcBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteOidcBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteOidcConflict_EncodeDecode(t *testing.T) {
	var typ DeleteOidcConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteOidcConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteOidcInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteOidcInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteOidcInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteOidcNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteOidcNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteOidcNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteOidcUnauthorized_EncodeDecode(t *testing.T) {
	var typ DeleteOidcUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteOidcUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteRouteBadRequest_EncodeDecode(t *testing.T) {
	var typ DeleteRouteBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteRouteBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteRouteInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteRouteInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteRouteInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteRouteNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteRouteNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteRouteNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteRouteUnauthorized_EncodeDecode(t *testing.T) {
	var typ DeleteRouteUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteRouteUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteServiceBadRequest_EncodeDecode(t *testing.T) {
	var typ DeleteServiceBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteServiceBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteServiceInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteServiceInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteServiceInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteServiceNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteServiceNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteServiceNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteServiceUnauthorized_EncodeDecode(t *testing.T) {
	var typ DeleteServiceUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteServiceUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteUserBadRequest_EncodeDecode(t *testing.T) {
	var typ DeleteUserBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteUserBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteUserInternalServerError_EncodeDecode(t *testing.T) {
	var typ DeleteUserInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteUserInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteUserNotFound_EncodeDecode(t *testing.T) {
	var typ DeleteUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomain_EncodeDecode(t *testing.T) {
	var typ Domain
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Domain
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDomainPUT_EncodeDecode(t *testing.T) {
	var typ DomainPUT
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DomainPUT
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestErrorSchema_EncodeDecode(t *testing.T) {
	var typ ErrorSchema
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ErrorSchema
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCertificatesBadRequest_EncodeDecode(t *testing.T) {
	var typ GetCertificatesBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCertificatesBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCertificatesInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetCertificatesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCertificatesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCertificatesOK_EncodeDecode(t *testing.T) {
	var typ GetCertificatesOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCertificatesOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCertificatesUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetCertificatesUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCertificatesUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetDomainsBadRequest_EncodeDecode(t *testing.T) {
	var typ GetDomainsBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetDomainsBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetDomainsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetDomainsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetDomainsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetDomainsOK_EncodeDecode(t *testing.T) {
	var typ GetDomainsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetDomainsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetDomainsUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetDomainsUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetDomainsUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetGroupBadRequest_EncodeDecode(t *testing.T) {
	var typ GetGroupBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetGroupBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetGroupInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetGroupInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetGroupInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetGroupNotFound_EncodeDecode(t *testing.T) {
	var typ GetGroupNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetGroupNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetGroupOK_EncodeDecode(t *testing.T) {
	var typ GetGroupOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetGroupOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetGroupOKApigw_EncodeDecode(t *testing.T) {
	var typ GetGroupOKApigw
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetGroupOKApigw
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetGroupsBadRequest_EncodeDecode(t *testing.T) {
	var typ GetGroupsBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetGroupsBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetGroupsInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetGroupsInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetGroupsInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetGroupsOK_EncodeDecode(t *testing.T) {
	var typ GetGroupsOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetGroupsOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetGroupsUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetGroupsUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetGroupsUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetOidcBadRequest_EncodeDecode(t *testing.T) {
	var typ GetOidcBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetOidcBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetOidcByIdBadRequest_EncodeDecode(t *testing.T) {
	var typ GetOidcByIdBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetOidcByIdBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetOidcByIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetOidcByIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetOidcByIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetOidcByIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetOidcByIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetOidcByIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetOidcByIdOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ GetOidcByIdOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetOidcByIdOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetOidcByIdUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetOidcByIdUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetOidcByIdUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetOidcInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetOidcInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetOidcInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetOidcNotFound_EncodeDecode(t *testing.T) {
	var typ GetOidcNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetOidcNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetOidcOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ GetOidcOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetOidcOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetOidcUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetOidcUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetOidcUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPlansOK_EncodeDecode(t *testing.T) {
	var typ GetPlansOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPlansOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRequestTransformationBadRequest_EncodeDecode(t *testing.T) {
	var typ GetRequestTransformationBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRequestTransformationBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRequestTransformationInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetRequestTransformationInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRequestTransformationInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRequestTransformationNotFound_EncodeDecode(t *testing.T) {
	var typ GetRequestTransformationNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRequestTransformationNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRequestTransformationOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ GetRequestTransformationOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRequestTransformationOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRequestTransformationUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetRequestTransformationUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRequestTransformationUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetResponseTransformationBadRequest_EncodeDecode(t *testing.T) {
	var typ GetResponseTransformationBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetResponseTransformationBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetResponseTransformationInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetResponseTransformationInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetResponseTransformationInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetResponseTransformationNotFound_EncodeDecode(t *testing.T) {
	var typ GetResponseTransformationNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetResponseTransformationNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetResponseTransformationOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ GetResponseTransformationOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetResponseTransformationOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetResponseTransformationUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetResponseTransformationUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetResponseTransformationUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRouteAuthorizationBadRequest_EncodeDecode(t *testing.T) {
	var typ GetRouteAuthorizationBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRouteAuthorizationBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRouteAuthorizationInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetRouteAuthorizationInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRouteAuthorizationInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRouteAuthorizationNotFound_EncodeDecode(t *testing.T) {
	var typ GetRouteAuthorizationNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRouteAuthorizationNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRouteAuthorizationOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ GetRouteAuthorizationOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRouteAuthorizationOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRouteAuthorizationUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetRouteAuthorizationUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRouteAuthorizationUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRouteBadRequest_EncodeDecode(t *testing.T) {
	var typ GetRouteBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRouteBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRouteInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetRouteInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRouteInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRouteNotFound_EncodeDecode(t *testing.T) {
	var typ GetRouteNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRouteNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRouteOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ GetRouteOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRouteOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRouteUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetRouteUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRouteUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServiceByIdBadRequest_EncodeDecode(t *testing.T) {
	var typ GetServiceByIdBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServiceByIdBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServiceByIdInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetServiceByIdInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServiceByIdInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServiceByIdNotFound_EncodeDecode(t *testing.T) {
	var typ GetServiceByIdNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServiceByIdNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServiceByIdOK_EncodeDecode(t *testing.T) {
	var typ GetServiceByIdOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServiceByIdOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServiceByIdOKApigw_EncodeDecode(t *testing.T) {
	var typ GetServiceByIdOKApigw
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServiceByIdOKApigw
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServiceRoutesBadRequest_EncodeDecode(t *testing.T) {
	var typ GetServiceRoutesBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServiceRoutesBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServiceRoutesInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetServiceRoutesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServiceRoutesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServiceRoutesNotFound_EncodeDecode(t *testing.T) {
	var typ GetServiceRoutesNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServiceRoutesNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServiceRoutesOK_EncodeDecode(t *testing.T) {
	var typ GetServiceRoutesOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServiceRoutesOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServiceRoutesUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetServiceRoutesUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServiceRoutesUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServicesBadRequest_EncodeDecode(t *testing.T) {
	var typ GetServicesBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServicesBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServicesInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetServicesInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServicesInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServicesOK_EncodeDecode(t *testing.T) {
	var typ GetServicesOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServicesOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetServicesUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetServicesUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetServicesUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionOK_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionOKApigw_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionOKApigw
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionOKApigw
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserAuthenticationBadRequest_EncodeDecode(t *testing.T) {
	var typ GetUserAuthenticationBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserAuthenticationBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserAuthenticationInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetUserAuthenticationInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserAuthenticationInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserAuthenticationNotFound_EncodeDecode(t *testing.T) {
	var typ GetUserAuthenticationNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserAuthenticationNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserAuthenticationOK_EncodeDecode(t *testing.T) {
	var typ GetUserAuthenticationOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserAuthenticationOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserAuthenticationOKApigw_EncodeDecode(t *testing.T) {
	var typ GetUserAuthenticationOKApigw
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserAuthenticationOKApigw
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserAuthenticationUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetUserAuthenticationUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserAuthenticationUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserBadRequest_EncodeDecode(t *testing.T) {
	var typ GetUserBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserGroupBadRequest_EncodeDecode(t *testing.T) {
	var typ GetUserGroupBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserGroupBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserGroupInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetUserGroupInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserGroupInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserGroupNotFound_EncodeDecode(t *testing.T) {
	var typ GetUserGroupNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserGroupNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserGroupOK_EncodeDecode(t *testing.T) {
	var typ GetUserGroupOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserGroupOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserGroupOKApigw_EncodeDecode(t *testing.T) {
	var typ GetUserGroupOKApigw
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserGroupOKApigw
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetUserInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserNotFound_EncodeDecode(t *testing.T) {
	var typ GetUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserOK_EncodeDecode(t *testing.T) {
	var typ GetUserOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserOKApigw_EncodeDecode(t *testing.T) {
	var typ GetUserOKApigw
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserOKApigw
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersBadRequest_EncodeDecode(t *testing.T) {
	var typ GetUsersBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersInternalServerError_EncodeDecode(t *testing.T) {
	var typ GetUsersInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersOK_EncodeDecode(t *testing.T) {
	var typ GetUsersOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersOKApigw_EncodeDecode(t *testing.T) {
	var typ GetUsersOKApigw
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersOKApigw
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUsersUnauthorized_EncodeDecode(t *testing.T) {
	var typ GetUsersUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUsersUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGroup_EncodeDecode(t *testing.T) {
	var typ Group
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Group
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHTTPMethod_EncodeDecode(t *testing.T) {
	var typ HTTPMethod
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HTTPMethod
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHmacAuth_EncodeDecode(t *testing.T) {
	var typ HmacAuth
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HmacAuth
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJSONKey_EncodeDecode(t *testing.T) {
	var typ JSONKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JSONKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJwt_EncodeDecode(t *testing.T) {
	var typ Jwt
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Jwt
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestJwtAlgorithm_EncodeDecode(t *testing.T) {
	var typ JwtAlgorithm
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 JwtAlgorithm
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestJwtAlgorithm_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"HS256\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ JwtAlgorithm

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 JwtAlgorithm
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestName_EncodeDecode(t *testing.T) {
	var typ Name
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Name
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOidc_EncodeDecode(t *testing.T) {
	var typ Oidc
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Oidc
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOidcProtocolsItem_EncodeDecode(t *testing.T) {
	var typ OidcProtocolsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OidcProtocolsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestOidcProtocolsItem_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"https\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ OidcProtocolsItem

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 OidcProtocolsItem
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPlan_EncodeDecode(t *testing.T) {
	var typ Plan
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Plan
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPlanMaxRequestsUnit_EncodeDecode(t *testing.T) {
	var typ PlanMaxRequestsUnit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PlanMaxRequestsUnit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPlanMaxRequestsUnit_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"day\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PlanMaxRequestsUnit

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PlanMaxRequestsUnit
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestQueryParamKey_EncodeDecode(t *testing.T) {
	var typ QueryParamKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 QueryParamKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestQueryParamValue_EncodeDecode(t *testing.T) {
	var typ QueryParamValue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 QueryParamValue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRequestAllowDetail_EncodeDecode(t *testing.T) {
	var typ RequestAllowDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RequestAllowDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRequestHeaderKey_EncodeDecode(t *testing.T) {
	var typ RequestHeaderKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RequestHeaderKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRequestHeaderValue_EncodeDecode(t *testing.T) {
	var typ RequestHeaderValue
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RequestHeaderValue
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRequestRemoveDetail_EncodeDecode(t *testing.T) {
	var typ RequestRemoveDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RequestRemoveDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRequestRenameDetail_EncodeDecode(t *testing.T) {
	var typ RequestRenameDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RequestRenameDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRequestRenameDetailBodyItem_EncodeDecode(t *testing.T) {
	var typ RequestRenameDetailBodyItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RequestRenameDetailBodyItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRequestRenameDetailHeadersItem_EncodeDecode(t *testing.T) {
	var typ RequestRenameDetailHeadersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RequestRenameDetailHeadersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRequestRenameDetailQueryParamsItem_EncodeDecode(t *testing.T) {
	var typ RequestRenameDetailQueryParamsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RequestRenameDetailQueryParamsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRequestTransformation_EncodeDecode(t *testing.T) {
	var typ RequestTransformation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RequestTransformation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseAllowDetail_EncodeDecode(t *testing.T) {
	var typ ResponseAllowDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseAllowDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseHeaderKey_EncodeDecode(t *testing.T) {
	var typ ResponseHeaderKey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseHeaderKey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseModification_EncodeDecode(t *testing.T) {
	var typ ResponseModification
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseModification
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseModificationBodyItem_EncodeDecode(t *testing.T) {
	var typ ResponseModificationBodyItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseModificationBodyItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseModificationDetail_EncodeDecode(t *testing.T) {
	var typ ResponseModificationDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseModificationDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseModificationDetailHeadersItem_EncodeDecode(t *testing.T) {
	var typ ResponseModificationDetailHeadersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseModificationDetailHeadersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseModificationDetailJSONItem_EncodeDecode(t *testing.T) {
	var typ ResponseModificationDetailJSONItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseModificationDetailJSONItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseModificationHeadersItem_EncodeDecode(t *testing.T) {
	var typ ResponseModificationHeadersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseModificationHeadersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseModificationQueryParamsItem_EncodeDecode(t *testing.T) {
	var typ ResponseModificationQueryParamsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseModificationQueryParamsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseRemoveDetail_EncodeDecode(t *testing.T) {
	var typ ResponseRemoveDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseRemoveDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseRenameDetail_EncodeDecode(t *testing.T) {
	var typ ResponseRenameDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseRenameDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseRenameDetailHeadersItem_EncodeDecode(t *testing.T) {
	var typ ResponseRenameDetailHeadersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseRenameDetailHeadersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseRenameDetailJSONItem_EncodeDecode(t *testing.T) {
	var typ ResponseRenameDetailJSONItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseRenameDetailJSONItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseReplaceDetail_EncodeDecode(t *testing.T) {
	var typ ResponseReplaceDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseReplaceDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseReplaceDetailHeadersItem_EncodeDecode(t *testing.T) {
	var typ ResponseReplaceDetailHeadersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseReplaceDetailHeadersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseReplaceDetailJSONItem_EncodeDecode(t *testing.T) {
	var typ ResponseReplaceDetailJSONItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseReplaceDetailJSONItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseTransformation_EncodeDecode(t *testing.T) {
	var typ ResponseTransformation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseTransformation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRouteAuthorization_EncodeDecode(t *testing.T) {
	var typ RouteAuthorization
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RouteAuthorization
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRouteAuthorizationDetail_EncodeDecode(t *testing.T) {
	var typ RouteAuthorizationDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RouteAuthorizationDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRouteAuthorizationDetailSum_EncodeDecode(t *testing.T) {
	var typ RouteAuthorizationDetailSum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RouteAuthorizationDetailSum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRouteAuthorizationDetailSum0_EncodeDecode(t *testing.T) {
	var typ RouteAuthorizationDetailSum0
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RouteAuthorizationDetailSum0
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRouteAuthorizationDetailSum0IsACLEnabled_EncodeDecode(t *testing.T) {
	var typ RouteAuthorizationDetailSum0IsACLEnabled
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RouteAuthorizationDetailSum0IsACLEnabled
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRouteAuthorizationDetailSum1_EncodeDecode(t *testing.T) {
	var typ RouteAuthorizationDetailSum1
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RouteAuthorizationDetailSum1
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRouteAuthorizationDetailSum1IsACLEnabled_EncodeDecode(t *testing.T) {
	var typ RouteAuthorizationDetailSum1IsACLEnabled
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RouteAuthorizationDetailSum1IsACLEnabled
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRouteDetail_EncodeDecode(t *testing.T) {
	var typ RouteDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RouteDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRouteDetailHttpsRedirectStatusCode_EncodeDecode(t *testing.T) {
	var typ RouteDetailHttpsRedirectStatusCode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RouteDetailHttpsRedirectStatusCode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRouteDetailHttpsRedirectStatusCode_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "426"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RouteDetailHttpsRedirectStatusCode

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RouteDetailHttpsRedirectStatusCode
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestRouteDetailProtocols_EncodeDecode(t *testing.T) {
	var typ RouteDetailProtocols
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RouteDetailProtocols
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestRouteDetailProtocols_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"http,https\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ RouteDetailProtocols

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 RouteDetailProtocols
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestServiceDetail_EncodeDecode(t *testing.T) {
	var typ ServiceDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServiceDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServiceDetailAuthentication_EncodeDecode(t *testing.T) {
	var typ ServiceDetailAuthentication
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServiceDetailAuthentication
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServiceDetailProtocol_EncodeDecode(t *testing.T) {
	var typ ServiceDetailProtocol
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServiceDetailProtocol
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestServiceDetailProtocol_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"https\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ ServiceDetailProtocol

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 ServiceDetailProtocol
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestSubscribeBadRequest_EncodeDecode(t *testing.T) {
	var typ SubscribeBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscribeBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscribeInternalServerError_EncodeDecode(t *testing.T) {
	var typ SubscribeInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscribeInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscribeUnauthorized_EncodeDecode(t *testing.T) {
	var typ SubscribeUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscribeUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscribed_EncodeDecode(t *testing.T) {
	var typ Subscribed
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Subscribed
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscribedStatus_EncodeDecode(t *testing.T) {
	var typ SubscribedStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscribedStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionOption_EncodeDecode(t *testing.T) {
	var typ SubscriptionOption
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionOption
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionStatus_EncodeDecode(t *testing.T) {
	var typ SubscriptionStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionStatusSum_EncodeDecode(t *testing.T) {
	var typ SubscriptionStatusSum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionStatusSum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTags_EncodeDecode(t *testing.T) {
	var typ Tags
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Tags
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnsubscribeBadRequest_EncodeDecode(t *testing.T) {
	var typ UnsubscribeBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnsubscribeBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnsubscribeInternalServerError_EncodeDecode(t *testing.T) {
	var typ UnsubscribeInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnsubscribeInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnsubscribeNotFound_EncodeDecode(t *testing.T) {
	var typ UnsubscribeNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnsubscribeNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnsubscribed_EncodeDecode(t *testing.T) {
	var typ Unsubscribed
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Unsubscribed
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnsubscribedStatus_EncodeDecode(t *testing.T) {
	var typ UnsubscribedStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnsubscribedStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestUnsubscribedStatus_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "\"unsubscribed\""},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ UnsubscribedStatus

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				if validateErr, ok := errors.Into[*validate.Error](err); ok {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 UnsubscribedStatus
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestUpdateCertificateBadRequest_EncodeDecode(t *testing.T) {
	var typ UpdateCertificateBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateCertificateBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateCertificateConflict_EncodeDecode(t *testing.T) {
	var typ UpdateCertificateConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateCertificateConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateCertificateInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpdateCertificateInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateCertificateInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateCertificateNotFound_EncodeDecode(t *testing.T) {
	var typ UpdateCertificateNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateCertificateNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateCertificateUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpdateCertificateUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateCertificateUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateCertificateUnprocessableEntity_EncodeDecode(t *testing.T) {
	var typ UpdateCertificateUnprocessableEntity
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateCertificateUnprocessableEntity
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateDomainBadRequest_EncodeDecode(t *testing.T) {
	var typ UpdateDomainBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateDomainBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateDomainConflict_EncodeDecode(t *testing.T) {
	var typ UpdateDomainConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateDomainConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateDomainInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpdateDomainInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateDomainInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateDomainNotFound_EncodeDecode(t *testing.T) {
	var typ UpdateDomainNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateDomainNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateDomainUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpdateDomainUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateDomainUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateGroupBadRequest_EncodeDecode(t *testing.T) {
	var typ UpdateGroupBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateGroupBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateGroupConflict_EncodeDecode(t *testing.T) {
	var typ UpdateGroupConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateGroupConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateGroupInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpdateGroupInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateGroupInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateGroupNotFound_EncodeDecode(t *testing.T) {
	var typ UpdateGroupNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateGroupNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateGroupUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpdateGroupUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateGroupUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateOidcBadRequest_EncodeDecode(t *testing.T) {
	var typ UpdateOidcBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateOidcBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateOidcConflict_EncodeDecode(t *testing.T) {
	var typ UpdateOidcConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateOidcConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateOidcInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpdateOidcInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateOidcInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateOidcNotFound_EncodeDecode(t *testing.T) {
	var typ UpdateOidcNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateOidcNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateOidcUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpdateOidcUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateOidcUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRouteBadRequest_EncodeDecode(t *testing.T) {
	var typ UpdateRouteBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRouteBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRouteConflict_EncodeDecode(t *testing.T) {
	var typ UpdateRouteConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRouteConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRouteInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpdateRouteInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRouteInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRouteNotFound_EncodeDecode(t *testing.T) {
	var typ UpdateRouteNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRouteNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRouteUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpdateRouteUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRouteUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateServiceBadRequest_EncodeDecode(t *testing.T) {
	var typ UpdateServiceBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateServiceBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateServiceConflict_EncodeDecode(t *testing.T) {
	var typ UpdateServiceConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateServiceConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateServiceInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpdateServiceInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateServiceInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateServiceNotFound_EncodeDecode(t *testing.T) {
	var typ UpdateServiceNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateServiceNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateServiceUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpdateServiceUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateServiceUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionBadRequest_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserBadRequest_EncodeDecode(t *testing.T) {
	var typ UpdateUserBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserConflict_EncodeDecode(t *testing.T) {
	var typ UpdateUserConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserGroupBadRequest_EncodeDecode(t *testing.T) {
	var typ UpdateUserGroupBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserGroupBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserGroupInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpdateUserGroupInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserGroupInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserGroupNotFound_EncodeDecode(t *testing.T) {
	var typ UpdateUserGroupNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserGroupNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserGroupUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpdateUserGroupUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserGroupUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpdateUserInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserNotFound_EncodeDecode(t *testing.T) {
	var typ UpdateUserNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpdateUserUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertRequestTransformationBadRequest_EncodeDecode(t *testing.T) {
	var typ UpsertRequestTransformationBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertRequestTransformationBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertRequestTransformationInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpsertRequestTransformationInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertRequestTransformationInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertRequestTransformationNotFound_EncodeDecode(t *testing.T) {
	var typ UpsertRequestTransformationNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertRequestTransformationNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertResponseTransformationBadRequest_EncodeDecode(t *testing.T) {
	var typ UpsertResponseTransformationBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertResponseTransformationBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertResponseTransformationInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpsertResponseTransformationInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertResponseTransformationInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertResponseTransformationNotFound_EncodeDecode(t *testing.T) {
	var typ UpsertResponseTransformationNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertResponseTransformationNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertResponseTransformationUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpsertResponseTransformationUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertResponseTransformationUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertRouteAuthorizationBadRequest_EncodeDecode(t *testing.T) {
	var typ UpsertRouteAuthorizationBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertRouteAuthorizationBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertRouteAuthorizationInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpsertRouteAuthorizationInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertRouteAuthorizationInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertRouteAuthorizationNotFound_EncodeDecode(t *testing.T) {
	var typ UpsertRouteAuthorizationNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertRouteAuthorizationNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertRouteAuthorizationUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpsertRouteAuthorizationUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertRouteAuthorizationUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertUserAuthenticationBadRequest_EncodeDecode(t *testing.T) {
	var typ UpsertUserAuthenticationBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertUserAuthenticationBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertUserAuthenticationInternalServerError_EncodeDecode(t *testing.T) {
	var typ UpsertUserAuthenticationInternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertUserAuthenticationInternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertUserAuthenticationNotFound_EncodeDecode(t *testing.T) {
	var typ UpsertUserAuthenticationNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertUserAuthenticationNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpsertUserAuthenticationUnauthorized_EncodeDecode(t *testing.T) {
	var typ UpsertUserAuthenticationUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpsertUserAuthenticationUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUser_EncodeDecode(t *testing.T) {
	var typ User
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 User
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserAuthentication_EncodeDecode(t *testing.T) {
	var typ UserAuthentication
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserAuthentication
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserDetail_EncodeDecode(t *testing.T) {
	var typ UserDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserGroupDetail_EncodeDecode(t *testing.T) {
	var typ UserGroupDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserGroupDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
