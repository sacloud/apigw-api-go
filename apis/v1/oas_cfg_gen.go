// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"net/http"

	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenregex"
)

var regexMap = map[string]ogenregex.Regexp{
	"^((([a-zA-Z\\d][a-zA-Z\\d-]*[a-zA-Z\\d]*\\.)+[a-zA-Z]{2,})|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)))$": ogenregex.MustCompile("^((([a-zA-Z\\d][a-zA-Z\\d-]*[a-zA-Z\\d]*\\.)+[a-zA-Z]{2,})|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)))$"),
	"^([\\w\\-._~!$&'()*+,;=:%]|%[0-9a-fA-F]{2})*$":                    ogenregex.MustCompile("^([\\w\\-._~!$&'()*+,;=:%]|%[0-9a-fA-F]{2})*$"),
	"^([a-zA-Z0-9_~\\-\\\\\\p{L}]+(\\.[a-zA-Z0-9_~\\-\\\\\\p{L}]+)*)$": ogenregex.MustCompile("^([a-zA-Z0-9_~\\-\\\\\\p{L}]+(\\.[a-zA-Z0-9_~\\-\\\\\\p{L}]+)*)$"),
	"^(\\/|~\\/).*": ogenregex.MustCompile("^(\\/|~\\/).*"),
	"^-----BEGIN CERTIFICATE-----\\r?\\n(?:[A-Za-z0-9+/=\\r\\n]+)-----END CERTIFICATE-----\\r?\\n?$": ogenregex.MustCompile("^-----BEGIN CERTIFICATE-----\\r?\\n(?:[A-Za-z0-9+/=\\r\\n]+)-----END CERTIFICATE-----\\r?\\n?$"),
	"^[\\p{L}\\p{N}._\\-]+$":   ogenregex.MustCompile("^[\\p{L}\\p{N}._\\-]+$"),
	"^[\\x20-\\x7E]*$":         ogenregex.MustCompile("^[\\x20-\\x7E]*$"),
	"^[^\\/\\s\\u3000]+$":      ogenregex.MustCompile("^[^\\/\\s\\u3000]+$"),
	"^[a-zA-Z0-9-]+$":          ogenregex.MustCompile("^[a-zA-Z0-9-]+$"),
	"^[a-zA-Z0-9-_.]+$":        ogenregex.MustCompile("^[a-zA-Z0-9-_.]+$"),
	"^[a-zA-Z0-9-_]+$":         ogenregex.MustCompile("^[a-zA-Z0-9-_]+$"),
	"^\\/[a-zA-Z0-9_\\-\\/]*$": ogenregex.MustCompile("^\\/[a-zA-Z0-9_\\-\\/]*$"),
	"^\\s*(([a-z\\d]([a-z\\d-]*[a-z\\d])?)\\.)+([a-z\\d-]{2,})(\\.)?\\s*$": ogenregex.MustCompile("^\\s*(([a-z\\d]([a-z\\d-]*[a-z\\d])?)\\.)+([a-z\\d-]{2,})(\\.)?\\s*$"),
}

type (
	optionFunc[C any] func(*C)
)

type clientConfig struct {
	Client ht.Client
}

// ClientOption is client config option.
type ClientOption interface {
	applyClient(*clientConfig)
}

var _ ClientOption = (optionFunc[clientConfig])(nil)

func (o optionFunc[C]) applyClient(c *C) {
	o(c)
}

func newClientConfig(opts ...ClientOption) clientConfig {
	cfg := clientConfig{
		Client: http.DefaultClient,
	}
	for _, opt := range opts {
		opt.applyClient(&cfg)
	}
	return cfg
}

type baseClient struct {
	cfg clientConfig
}

func (cfg clientConfig) baseClient() (c baseClient, err error) {
	c = baseClient{cfg: cfg}
	return c, nil
}

// Option is config option.
type Option interface {
	ClientOption
}

// WithClient specifies http client to use.
func WithClient(client ht.Client) ClientOption {
	return optionFunc[clientConfig](func(cfg *clientConfig) {
		if client != nil {
			cfg.Client = client
		}
	})
}
