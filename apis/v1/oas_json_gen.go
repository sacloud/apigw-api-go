// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"math/bits"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode encodes AddCertificateBadRequest as json.
func (s *AddCertificateBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddCertificateBadRequest from json.
func (s *AddCertificateBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddCertificateBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddCertificateBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddCertificateBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddCertificateBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddCertificateConflict as json.
func (s *AddCertificateConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddCertificateConflict from json.
func (s *AddCertificateConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddCertificateConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddCertificateConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddCertificateConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddCertificateConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddCertificateCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddCertificateCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfAddCertificateCreated = [1]string{
	0: "apigw",
}

// Decode decodes AddCertificateCreated from json.
func (s *AddCertificateCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddCertificateCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddCertificateCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddCertificateCreated) {
					name = jsonFieldsNameOfAddCertificateCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddCertificateCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddCertificateCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddCertificateCreatedApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddCertificateCreatedApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Certificate.Set {
			e.FieldStart("certificate")
			s.Certificate.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddCertificateCreatedApigw = [1]string{
	0: "certificate",
}

// Decode decodes AddCertificateCreatedApigw from json.
func (s *AddCertificateCreatedApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddCertificateCreatedApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificate":
			if err := func() error {
				s.Certificate.Reset()
				if err := s.Certificate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddCertificateCreatedApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddCertificateCreatedApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddCertificateCreatedApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddCertificateInternalServerError as json.
func (s *AddCertificateInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddCertificateInternalServerError from json.
func (s *AddCertificateInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddCertificateInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddCertificateInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddCertificateInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddCertificateInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddCertificateUnauthorized as json.
func (s *AddCertificateUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddCertificateUnauthorized from json.
func (s *AddCertificateUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddCertificateUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddCertificateUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddCertificateUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddCertificateUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddCertificateUnprocessableEntity as json.
func (s *AddCertificateUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddCertificateUnprocessableEntity from json.
func (s *AddCertificateUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddCertificateUnprocessableEntity to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddCertificateUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddCertificateUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddCertificateUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddDomainBadRequest as json.
func (s *AddDomainBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddDomainBadRequest from json.
func (s *AddDomainBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddDomainBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddDomainBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddDomainBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddDomainBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddDomainConflict as json.
func (s *AddDomainConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddDomainConflict from json.
func (s *AddDomainConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddDomainConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddDomainConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddDomainConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddDomainConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddDomainCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddDomainCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfAddDomainCreated = [1]string{
	0: "apigw",
}

// Decode decodes AddDomainCreated from json.
func (s *AddDomainCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddDomainCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddDomainCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddDomainCreated) {
					name = jsonFieldsNameOfAddDomainCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddDomainCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddDomainCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddDomainCreatedApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddDomainCreatedApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Domain.Set {
			e.FieldStart("domain")
			s.Domain.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddDomainCreatedApigw = [1]string{
	0: "domain",
}

// Decode decodes AddDomainCreatedApigw from json.
func (s *AddDomainCreatedApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddDomainCreatedApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domain":
			if err := func() error {
				s.Domain.Reset()
				if err := s.Domain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domain\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddDomainCreatedApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddDomainCreatedApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddDomainCreatedApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddDomainInternalServerError as json.
func (s *AddDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddDomainInternalServerError from json.
func (s *AddDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddDomainInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddDomainUnauthorized as json.
func (s *AddDomainUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddDomainUnauthorized from json.
func (s *AddDomainUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddDomainUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddDomainUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddDomainUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddDomainUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddGroupBadRequest as json.
func (s *AddGroupBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddGroupBadRequest from json.
func (s *AddGroupBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddGroupBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddGroupBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddGroupBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddGroupBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddGroupConflict as json.
func (s *AddGroupConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddGroupConflict from json.
func (s *AddGroupConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddGroupConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddGroupConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddGroupConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddGroupConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddGroupCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddGroupCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfAddGroupCreated = [1]string{
	0: "apigw",
}

// Decode decodes AddGroupCreated from json.
func (s *AddGroupCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddGroupCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddGroupCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddGroupCreated) {
					name = jsonFieldsNameOfAddGroupCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddGroupCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddGroupCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddGroupCreatedApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddGroupCreatedApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Group.Set {
			e.FieldStart("group")
			s.Group.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddGroupCreatedApigw = [1]string{
	0: "group",
}

// Decode decodes AddGroupCreatedApigw from json.
func (s *AddGroupCreatedApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddGroupCreatedApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddGroupCreatedApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddGroupCreatedApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddGroupCreatedApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddGroupInternalServerError as json.
func (s *AddGroupInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddGroupInternalServerError from json.
func (s *AddGroupInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddGroupInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddGroupInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddGroupInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddGroupInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddGroupUnauthorized as json.
func (s *AddGroupUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddGroupUnauthorized from json.
func (s *AddGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddGroupUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddGroupUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddGroupUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddGroupUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddOidcBadRequest as json.
func (s *AddOidcBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddOidcBadRequest from json.
func (s *AddOidcBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddOidcBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddOidcBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddOidcBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddOidcBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddOidcConflict as json.
func (s *AddOidcConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddOidcConflict from json.
func (s *AddOidcConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddOidcConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddOidcConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddOidcConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddOidcConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddOidcCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddOidcCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfAddOidcCreated = [1]string{
	0: "apigw",
}

// Decode decodes AddOidcCreated from json.
func (s *AddOidcCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddOidcCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddOidcCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddOidcCreated) {
					name = jsonFieldsNameOfAddOidcCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddOidcCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddOidcCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddOidcCreatedApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddOidcCreatedApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Oidc.Set {
			e.FieldStart("oidc")
			s.Oidc.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddOidcCreatedApigw = [1]string{
	0: "oidc",
}

// Decode decodes AddOidcCreatedApigw from json.
func (s *AddOidcCreatedApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddOidcCreatedApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "oidc":
			if err := func() error {
				s.Oidc.Reset()
				if err := s.Oidc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidc\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddOidcCreatedApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddOidcCreatedApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddOidcCreatedApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddOidcInternalServerError as json.
func (s *AddOidcInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddOidcInternalServerError from json.
func (s *AddOidcInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddOidcInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddOidcInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddOidcInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddOidcInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddOidcNotFound as json.
func (s *AddOidcNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddOidcNotFound from json.
func (s *AddOidcNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddOidcNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddOidcNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddOidcNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddOidcNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddOidcUnauthorized as json.
func (s *AddOidcUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddOidcUnauthorized from json.
func (s *AddOidcUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddOidcUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddOidcUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddOidcUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddOidcUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddOidcUnprocessableEntity as json.
func (s *AddOidcUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddOidcUnprocessableEntity from json.
func (s *AddOidcUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddOidcUnprocessableEntity to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddOidcUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddOidcUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddOidcUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRouteBadRequest as json.
func (s *AddRouteBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddRouteBadRequest from json.
func (s *AddRouteBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRouteBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddRouteBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRouteBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRouteBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRouteConflict as json.
func (s *AddRouteConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddRouteConflict from json.
func (s *AddRouteConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRouteConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddRouteConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRouteConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRouteConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddRouteCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddRouteCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfAddRouteCreated = [1]string{
	0: "apigw",
}

// Decode decodes AddRouteCreated from json.
func (s *AddRouteCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRouteCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddRouteCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddRouteCreated) {
					name = jsonFieldsNameOfAddRouteCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRouteCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRouteCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddRouteCreatedApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddRouteCreatedApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Route.Set {
			e.FieldStart("route")
			s.Route.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddRouteCreatedApigw = [1]string{
	0: "route",
}

// Decode decodes AddRouteCreatedApigw from json.
func (s *AddRouteCreatedApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRouteCreatedApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "route":
			if err := func() error {
				s.Route.Reset()
				if err := s.Route.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"route\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddRouteCreatedApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRouteCreatedApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRouteCreatedApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRouteInternalServerError as json.
func (s *AddRouteInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddRouteInternalServerError from json.
func (s *AddRouteInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRouteInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddRouteInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRouteInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRouteInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRouteNotFound as json.
func (s *AddRouteNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddRouteNotFound from json.
func (s *AddRouteNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRouteNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddRouteNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRouteNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRouteNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddRouteUnauthorized as json.
func (s *AddRouteUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddRouteUnauthorized from json.
func (s *AddRouteUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddRouteUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddRouteUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddRouteUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddRouteUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddServiceBadRequest as json.
func (s *AddServiceBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddServiceBadRequest from json.
func (s *AddServiceBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddServiceBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddServiceBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddServiceBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddServiceBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddServiceConflict as json.
func (s *AddServiceConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddServiceConflict from json.
func (s *AddServiceConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddServiceConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddServiceConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddServiceConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddServiceConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddServiceCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddServiceCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfAddServiceCreated = [1]string{
	0: "apigw",
}

// Decode decodes AddServiceCreated from json.
func (s *AddServiceCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddServiceCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddServiceCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddServiceCreated) {
					name = jsonFieldsNameOfAddServiceCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddServiceCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddServiceCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddServiceCreatedApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddServiceCreatedApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Service.Set {
			e.FieldStart("service")
			s.Service.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddServiceCreatedApigw = [1]string{
	0: "service",
}

// Decode decodes AddServiceCreatedApigw from json.
func (s *AddServiceCreatedApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddServiceCreatedApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddServiceCreatedApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddServiceCreatedApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddServiceCreatedApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddServiceInternalServerError as json.
func (s *AddServiceInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddServiceInternalServerError from json.
func (s *AddServiceInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddServiceInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddServiceInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddServiceInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddServiceInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddServiceNotFound as json.
func (s *AddServiceNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddServiceNotFound from json.
func (s *AddServiceNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddServiceNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddServiceNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddServiceNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddServiceNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddServiceUnauthorized as json.
func (s *AddServiceUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddServiceUnauthorized from json.
func (s *AddServiceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddServiceUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddServiceUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddServiceUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddServiceUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddServiceUnprocessableEntity as json.
func (s *AddServiceUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddServiceUnprocessableEntity from json.
func (s *AddServiceUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddServiceUnprocessableEntity to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddServiceUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddServiceUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddServiceUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddUserBadRequest as json.
func (s *AddUserBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddUserBadRequest from json.
func (s *AddUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUserBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddUserBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddUserConflict as json.
func (s *AddUserConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddUserConflict from json.
func (s *AddUserConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUserConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddUserConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUserConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUserConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddUserCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddUserCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfAddUserCreated = [1]string{
	0: "apigw",
}

// Decode decodes AddUserCreated from json.
func (s *AddUserCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUserCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddUserCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddUserCreated) {
					name = jsonFieldsNameOfAddUserCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUserCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUserCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddUserCreatedApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddUserCreatedApigw) encodeFields(e *jx.Encoder) {
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddUserCreatedApigw = [1]string{
	0: "user",
}

// Decode decodes AddUserCreatedApigw from json.
func (s *AddUserCreatedApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUserCreatedApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddUserCreatedApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUserCreatedApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUserCreatedApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddUserInternalServerError as json.
func (s *AddUserInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes AddUserInternalServerError from json.
func (s *AddUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUserInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AddUserInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthenticationMethods as json.
func (s AuthenticationMethods) Encode(e *jx.Encoder) {
	unwrapped := []AuthenticationMethodsItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes AuthenticationMethods from json.
func (s *AuthenticationMethods) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationMethods to nil")
	}
	var unwrapped []AuthenticationMethodsItem
	if err := func() error {
		unwrapped = make([]AuthenticationMethodsItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem AuthenticationMethodsItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AuthenticationMethods(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthenticationMethods) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationMethods) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AuthenticationMethodsItem as json.
func (s AuthenticationMethodsItem) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AuthenticationMethodsItem from json.
func (s *AuthenticationMethodsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthenticationMethodsItem to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AuthenticationMethodsItem(v) {
	case AuthenticationMethodsItemAuthorizationCodeFlow:
		*s = AuthenticationMethodsItemAuthorizationCodeFlow
	case AuthenticationMethodsItemAccessToken:
		*s = AuthenticationMethodsItemAccessToken
	default:
		*s = AuthenticationMethodsItem(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AuthenticationMethodsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthenticationMethodsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BasicAuth) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BasicAuth) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("userName")
		e.Str(s.UserName)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfBasicAuth = [5]string{
	0: "id",
	1: "createdAt",
	2: "updatedAt",
	3: "userName",
	4: "password",
}

// Decode decodes BasicAuth from json.
func (s *BasicAuth) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BasicAuth to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "userName":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.UserName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userName\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BasicAuth")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBasicAuth) {
					name = jsonFieldsNameOfBasicAuth[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BasicAuth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BasicAuth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Certificate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Certificate) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Rsa.Set {
			e.FieldStart("rsa")
			s.Rsa.Encode(e)
		}
	}
	{
		if s.Ecdsa.Set {
			e.FieldStart("ecdsa")
			s.Ecdsa.Encode(e)
		}
	}
}

var jsonFieldsNameOfCertificate = [6]string{
	0: "id",
	1: "createdAt",
	2: "updatedAt",
	3: "name",
	4: "rsa",
	5: "ecdsa",
}

// Decode decodes Certificate from json.
func (s *Certificate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Certificate to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "rsa":
			if err := func() error {
				s.Rsa.Reset()
				if err := s.Rsa.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rsa\"")
			}
		case "ecdsa":
			if err := func() error {
				s.Ecdsa.Reset()
				if err := s.Ecdsa.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ecdsa\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Certificate")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Certificate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Certificate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateDTO) encodeFields(e *jx.Encoder) {
	{
		if s.Certificates != nil {
			e.FieldStart("certificates")
			e.ArrStart()
			for _, elem := range s.Certificates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCertificateDTO = [1]string{
	0: "certificates",
}

// Decode decodes CertificateDTO from json.
func (s *CertificateDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateDTO to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificates":
			if err := func() error {
				s.Certificates = make([]Certificate, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Certificate
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Certificates = append(s.Certificates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateDTO")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CertificateDetails) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CertificateDetails) encodeFields(e *jx.Encoder) {
	{
		if s.Cert.Set {
			e.FieldStart("cert")
			s.Cert.Encode(e)
		}
	}
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.ExpiredAt.Set {
			e.FieldStart("expiredAt")
			s.ExpiredAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCertificateDetails = [3]string{
	0: "cert",
	1: "key",
	2: "expiredAt",
}

// Decode decodes CertificateDetails from json.
func (s *CertificateDetails) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CertificateDetails to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cert":
			if err := func() error {
				s.Cert.Reset()
				if err := s.Cert.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cert\"")
			}
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "expiredAt":
			if err := func() error {
				s.ExpiredAt.Reset()
				if err := s.ExpiredAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiredAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CertificateDetails")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CertificateDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CertificateDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CorsConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CorsConfig) encodeFields(e *jx.Encoder) {
	{
		if s.Credentials.Set {
			e.FieldStart("credentials")
			s.Credentials.Encode(e)
		}
	}
	{
		if s.AccessControlExposedHeaders.Set {
			e.FieldStart("accessControlExposedHeaders")
			s.AccessControlExposedHeaders.Encode(e)
		}
	}
	{
		if s.AccessControlAllowHeaders.Set {
			e.FieldStart("accessControlAllowHeaders")
			s.AccessControlAllowHeaders.Encode(e)
		}
	}
	{
		if s.MaxAge.Set {
			e.FieldStart("maxAge")
			s.MaxAge.Encode(e)
		}
	}
	{
		if s.AccessControlAllowMethods != nil {
			e.FieldStart("accessControlAllowMethods")
			e.ArrStart()
			for _, elem := range s.AccessControlAllowMethods {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AccessControlAllowOrigins.Set {
			e.FieldStart("accessControlAllowOrigins")
			s.AccessControlAllowOrigins.Encode(e)
		}
	}
	{
		if s.PreflightContinue.Set {
			e.FieldStart("preflightContinue")
			s.PreflightContinue.Encode(e)
		}
	}
	{
		if s.PrivateNetwork.Set {
			e.FieldStart("privateNetwork")
			s.PrivateNetwork.Encode(e)
		}
	}
}

var jsonFieldsNameOfCorsConfig = [8]string{
	0: "credentials",
	1: "accessControlExposedHeaders",
	2: "accessControlAllowHeaders",
	3: "maxAge",
	4: "accessControlAllowMethods",
	5: "accessControlAllowOrigins",
	6: "preflightContinue",
	7: "privateNetwork",
}

// Decode decodes CorsConfig from json.
func (s *CorsConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CorsConfig to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "credentials":
			if err := func() error {
				s.Credentials.Reset()
				if err := s.Credentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"credentials\"")
			}
		case "accessControlExposedHeaders":
			if err := func() error {
				s.AccessControlExposedHeaders.Reset()
				if err := s.AccessControlExposedHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessControlExposedHeaders\"")
			}
		case "accessControlAllowHeaders":
			if err := func() error {
				s.AccessControlAllowHeaders.Reset()
				if err := s.AccessControlAllowHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessControlAllowHeaders\"")
			}
		case "maxAge":
			if err := func() error {
				s.MaxAge.Reset()
				if err := s.MaxAge.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxAge\"")
			}
		case "accessControlAllowMethods":
			if err := func() error {
				s.AccessControlAllowMethods = make([]HTTPMethod, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HTTPMethod
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AccessControlAllowMethods = append(s.AccessControlAllowMethods, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessControlAllowMethods\"")
			}
		case "accessControlAllowOrigins":
			if err := func() error {
				s.AccessControlAllowOrigins.Reset()
				if err := s.AccessControlAllowOrigins.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessControlAllowOrigins\"")
			}
		case "preflightContinue":
			if err := func() error {
				s.PreflightContinue.Reset()
				if err := s.PreflightContinue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preflightContinue\"")
			}
		case "privateNetwork":
			if err := func() error {
				s.PrivateNetwork.Reset()
				if err := s.PrivateNetwork.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privateNetwork\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CorsConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CorsConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CorsConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteCertificateBadRequest as json.
func (s *DeleteCertificateBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteCertificateBadRequest from json.
func (s *DeleteCertificateBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCertificateBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteCertificateBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCertificateBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCertificateBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteCertificateInternalServerError as json.
func (s *DeleteCertificateInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteCertificateInternalServerError from json.
func (s *DeleteCertificateInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCertificateInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteCertificateInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCertificateInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCertificateInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteCertificateNotFound as json.
func (s *DeleteCertificateNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteCertificateNotFound from json.
func (s *DeleteCertificateNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCertificateNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteCertificateNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCertificateNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCertificateNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteCertificateUnauthorized as json.
func (s *DeleteCertificateUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteCertificateUnauthorized from json.
func (s *DeleteCertificateUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteCertificateUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteCertificateUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteCertificateUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteCertificateUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteDomainBadRequest as json.
func (s *DeleteDomainBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteDomainBadRequest from json.
func (s *DeleteDomainBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteDomainBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteDomainBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteDomainBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteDomainBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteDomainInternalServerError as json.
func (s *DeleteDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteDomainInternalServerError from json.
func (s *DeleteDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteDomainInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteDomainNotFound as json.
func (s *DeleteDomainNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteDomainNotFound from json.
func (s *DeleteDomainNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteDomainNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteDomainNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteDomainNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteDomainNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteDomainUnauthorized as json.
func (s *DeleteDomainUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteDomainUnauthorized from json.
func (s *DeleteDomainUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteDomainUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteDomainUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteDomainUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteDomainUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteGroupBadRequest as json.
func (s *DeleteGroupBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteGroupBadRequest from json.
func (s *DeleteGroupBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteGroupBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteGroupBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteGroupBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteGroupBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteGroupInternalServerError as json.
func (s *DeleteGroupInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteGroupInternalServerError from json.
func (s *DeleteGroupInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteGroupInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteGroupInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteGroupInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteGroupInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteGroupNotFound as json.
func (s *DeleteGroupNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteGroupNotFound from json.
func (s *DeleteGroupNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteGroupNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteGroupNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteGroupNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteGroupNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteGroupUnauthorized as json.
func (s *DeleteGroupUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteGroupUnauthorized from json.
func (s *DeleteGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteGroupUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteGroupUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteGroupUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteGroupUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteOidcBadRequest as json.
func (s *DeleteOidcBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteOidcBadRequest from json.
func (s *DeleteOidcBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteOidcBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteOidcBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteOidcBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteOidcBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteOidcConflict as json.
func (s *DeleteOidcConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteOidcConflict from json.
func (s *DeleteOidcConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteOidcConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteOidcConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteOidcConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteOidcConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteOidcInternalServerError as json.
func (s *DeleteOidcInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteOidcInternalServerError from json.
func (s *DeleteOidcInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteOidcInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteOidcInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteOidcInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteOidcInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteOidcNotFound as json.
func (s *DeleteOidcNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteOidcNotFound from json.
func (s *DeleteOidcNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteOidcNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteOidcNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteOidcNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteOidcNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteOidcUnauthorized as json.
func (s *DeleteOidcUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteOidcUnauthorized from json.
func (s *DeleteOidcUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteOidcUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteOidcUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteOidcUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteOidcUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteRouteBadRequest as json.
func (s *DeleteRouteBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteRouteBadRequest from json.
func (s *DeleteRouteBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteRouteBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteRouteBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteRouteBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteRouteBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteRouteInternalServerError as json.
func (s *DeleteRouteInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteRouteInternalServerError from json.
func (s *DeleteRouteInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteRouteInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteRouteInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteRouteInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteRouteInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteRouteNotFound as json.
func (s *DeleteRouteNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteRouteNotFound from json.
func (s *DeleteRouteNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteRouteNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteRouteNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteRouteNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteRouteNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteRouteUnauthorized as json.
func (s *DeleteRouteUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteRouteUnauthorized from json.
func (s *DeleteRouteUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteRouteUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteRouteUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteRouteUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteRouteUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteServiceBadRequest as json.
func (s *DeleteServiceBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteServiceBadRequest from json.
func (s *DeleteServiceBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteServiceBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteServiceBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteServiceBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteServiceBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteServiceInternalServerError as json.
func (s *DeleteServiceInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteServiceInternalServerError from json.
func (s *DeleteServiceInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteServiceInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteServiceInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteServiceInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteServiceInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteServiceNotFound as json.
func (s *DeleteServiceNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteServiceNotFound from json.
func (s *DeleteServiceNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteServiceNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteServiceNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteServiceNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteServiceNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteServiceUnauthorized as json.
func (s *DeleteServiceUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteServiceUnauthorized from json.
func (s *DeleteServiceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteServiceUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteServiceUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteServiceUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteServiceUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteUserBadRequest as json.
func (s *DeleteUserBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteUserBadRequest from json.
func (s *DeleteUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteUserBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteUserInternalServerError as json.
func (s *DeleteUserInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteUserInternalServerError from json.
func (s *DeleteUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteUserInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DeleteUserNotFound as json.
func (s *DeleteUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes DeleteUserNotFound from json.
func (s *DeleteUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DeleteUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Domain) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Domain) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("domainName")
		e.Str(s.DomainName)
	}
	{
		if s.CertificateId.Set {
			e.FieldStart("certificateId")
			s.CertificateId.Encode(e)
		}
	}
	{
		if s.CertificateName.Set {
			e.FieldStart("certificateName")
			s.CertificateName.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomain = [6]string{
	0: "id",
	1: "createdAt",
	2: "updatedAt",
	3: "domainName",
	4: "certificateId",
	5: "certificateName",
}

// Decode decodes Domain from json.
func (s *Domain) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Domain to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "domainName":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.DomainName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domainName\"")
			}
		case "certificateId":
			if err := func() error {
				s.CertificateId.Reset()
				if err := s.CertificateId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificateId\"")
			}
		case "certificateName":
			if err := func() error {
				s.CertificateName.Reset()
				if err := s.CertificateName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificateName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Domain")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDomain) {
					name = jsonFieldsNameOfDomain[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Domain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Domain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainDTO) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainDTO) encodeFields(e *jx.Encoder) {
	{
		if s.Domains != nil {
			e.FieldStart("domains")
			e.ArrStart()
			for _, elem := range s.Domains {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfDomainDTO = [1]string{
	0: "domains",
}

// Decode decodes DomainDTO from json.
func (s *DomainDTO) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainDTO to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "domains":
			if err := func() error {
				s.Domains = make([]Domain, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Domain
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Domains = append(s.Domains, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"domains\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainDTO")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainDTO) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainDTO) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DomainPUT) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DomainPUT) encodeFields(e *jx.Encoder) {
	{
		if s.CertificateId.Set {
			e.FieldStart("certificateId")
			s.CertificateId.Encode(e)
		}
	}
}

var jsonFieldsNameOfDomainPUT = [1]string{
	0: "certificateId",
}

// Decode decodes DomainPUT from json.
func (s *DomainPUT) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DomainPUT to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "certificateId":
			if err := func() error {
				s.CertificateId.Reset()
				if err := s.CertificateId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"certificateId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DomainPUT")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DomainPUT) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DomainPUT) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ErrorSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ErrorSchema) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfErrorSchema = [1]string{
	0: "message",
}

// Decode decodes ErrorSchema from json.
func (s *ErrorSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ErrorSchema to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ErrorSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ErrorSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ErrorSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCertificatesBadRequest as json.
func (s *GetCertificatesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCertificatesBadRequest from json.
func (s *GetCertificatesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCertificatesBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCertificatesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCertificatesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCertificatesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCertificatesInternalServerError as json.
func (s *GetCertificatesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCertificatesInternalServerError from json.
func (s *GetCertificatesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCertificatesInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCertificatesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCertificatesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCertificatesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetCertificatesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetCertificatesOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetCertificatesOK = [1]string{
	0: "apigw",
}

// Decode decodes GetCertificatesOK from json.
func (s *GetCertificatesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCertificatesOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetCertificatesOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetCertificatesOK) {
					name = jsonFieldsNameOfGetCertificatesOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCertificatesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCertificatesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetCertificatesUnauthorized as json.
func (s *GetCertificatesUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetCertificatesUnauthorized from json.
func (s *GetCertificatesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetCertificatesUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetCertificatesUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetCertificatesUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetCertificatesUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainsBadRequest as json.
func (s *GetDomainsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainsBadRequest from json.
func (s *GetDomainsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainsBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainsInternalServerError as json.
func (s *GetDomainsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainsInternalServerError from json.
func (s *GetDomainsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainsInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetDomainsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetDomainsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetDomainsOK = [1]string{
	0: "apigw",
}

// Decode decodes GetDomainsOK from json.
func (s *GetDomainsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetDomainsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetDomainsOK) {
					name = jsonFieldsNameOfGetDomainsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetDomainsUnauthorized as json.
func (s *GetDomainsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetDomainsUnauthorized from json.
func (s *GetDomainsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetDomainsUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetDomainsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetDomainsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetDomainsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetGroupBadRequest as json.
func (s *GetGroupBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetGroupBadRequest from json.
func (s *GetGroupBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetGroupBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetGroupBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetGroupBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetGroupBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetGroupInternalServerError as json.
func (s *GetGroupInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetGroupInternalServerError from json.
func (s *GetGroupInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetGroupInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetGroupInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetGroupInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetGroupInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetGroupNotFound as json.
func (s *GetGroupNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetGroupNotFound from json.
func (s *GetGroupNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetGroupNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetGroupNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetGroupNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetGroupNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetGroupOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetGroupOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetGroupOK = [1]string{
	0: "apigw",
}

// Decode decodes GetGroupOK from json.
func (s *GetGroupOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetGroupOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetGroupOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetGroupOK) {
					name = jsonFieldsNameOfGetGroupOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetGroupOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetGroupOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetGroupOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetGroupOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Group.Set {
			e.FieldStart("group")
			s.Group.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetGroupOKApigw = [1]string{
	0: "group",
}

// Decode decodes GetGroupOKApigw from json.
func (s *GetGroupOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetGroupOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "group":
			if err := func() error {
				s.Group.Reset()
				if err := s.Group.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"group\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetGroupOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetGroupOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetGroupOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetGroupsBadRequest as json.
func (s *GetGroupsBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetGroupsBadRequest from json.
func (s *GetGroupsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetGroupsBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetGroupsBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetGroupsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetGroupsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetGroupsInternalServerError as json.
func (s *GetGroupsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetGroupsInternalServerError from json.
func (s *GetGroupsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetGroupsInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetGroupsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetGroupsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetGroupsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetGroupsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetGroupsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetGroupsOK = [1]string{
	0: "apigw",
}

// Decode decodes GetGroupsOK from json.
func (s *GetGroupsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetGroupsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetGroupsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetGroupsOK) {
					name = jsonFieldsNameOfGetGroupsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetGroupsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetGroupsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetGroupsOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetGroupsOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Groups != nil {
			e.FieldStart("groups")
			e.ArrStart()
			for _, elem := range s.Groups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetGroupsOKApigw = [1]string{
	0: "groups",
}

// Decode decodes GetGroupsOKApigw from json.
func (s *GetGroupsOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetGroupsOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			if err := func() error {
				s.Groups = make([]Group, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Group
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetGroupsOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetGroupsOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetGroupsOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetGroupsUnauthorized as json.
func (s *GetGroupsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetGroupsUnauthorized from json.
func (s *GetGroupsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetGroupsUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetGroupsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetGroupsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetGroupsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOidcBadRequest as json.
func (s *GetOidcBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetOidcBadRequest from json.
func (s *GetOidcBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOidcBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOidcBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOidcBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOidcBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOidcByIdBadRequest as json.
func (s *GetOidcByIdBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetOidcByIdBadRequest from json.
func (s *GetOidcByIdBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOidcByIdBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOidcByIdBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOidcByIdBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOidcByIdBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOidcByIdInternalServerError as json.
func (s *GetOidcByIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetOidcByIdInternalServerError from json.
func (s *GetOidcByIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOidcByIdInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOidcByIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOidcByIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOidcByIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOidcByIdNotFound as json.
func (s *GetOidcByIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetOidcByIdNotFound from json.
func (s *GetOidcByIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOidcByIdNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOidcByIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOidcByIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOidcByIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOidcByIdOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOidcByIdOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetOidcByIdOK = [1]string{
	0: "apigw",
}

// Decode decodes GetOidcByIdOK from json.
func (s *GetOidcByIdOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOidcByIdOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOidcByIdOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOidcByIdOK) {
					name = jsonFieldsNameOfGetOidcByIdOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOidcByIdOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOidcByIdOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOidcByIdOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOidcByIdOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Oidc.Set {
			e.FieldStart("oidc")
			s.Oidc.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetOidcByIdOKApigw = [1]string{
	0: "oidc",
}

// Decode decodes GetOidcByIdOKApigw from json.
func (s *GetOidcByIdOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOidcByIdOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "oidc":
			if err := func() error {
				s.Oidc.Reset()
				if err := s.Oidc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidc\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOidcByIdOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOidcByIdOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOidcByIdOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOidcByIdUnauthorized as json.
func (s *GetOidcByIdUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetOidcByIdUnauthorized from json.
func (s *GetOidcByIdUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOidcByIdUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOidcByIdUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOidcByIdUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOidcByIdUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOidcInternalServerError as json.
func (s *GetOidcInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetOidcInternalServerError from json.
func (s *GetOidcInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOidcInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOidcInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOidcInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOidcInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOidcNotFound as json.
func (s *GetOidcNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetOidcNotFound from json.
func (s *GetOidcNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOidcNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOidcNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOidcNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOidcNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOidcOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOidcOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetOidcOK = [1]string{
	0: "apigw",
}

// Decode decodes GetOidcOK from json.
func (s *GetOidcOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOidcOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOidcOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOidcOK) {
					name = jsonFieldsNameOfGetOidcOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOidcOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOidcOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOidcOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOidcOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Oidcs != nil {
			e.FieldStart("oidcs")
			e.ArrStart()
			for _, elem := range s.Oidcs {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetOidcOKApigw = [1]string{
	0: "oidcs",
}

// Decode decodes GetOidcOKApigw from json.
func (s *GetOidcOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOidcOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "oidcs":
			if err := func() error {
				s.Oidcs = make([]Oidc, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Oidc
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Oidcs = append(s.Oidcs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidcs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOidcOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOidcOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOidcOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOidcUnauthorized as json.
func (s *GetOidcUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetOidcUnauthorized from json.
func (s *GetOidcUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOidcUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOidcUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOidcUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOidcUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlansOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlansOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetPlansOK = [1]string{
	0: "apigw",
}

// Decode decodes GetPlansOK from json.
func (s *GetPlansOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlansOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPlansOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPlansOK) {
					name = jsonFieldsNameOfGetPlansOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlansOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlansOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPlansOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPlansOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Plans != nil {
			e.FieldStart("plans")
			e.ArrStart()
			for _, elem := range s.Plans {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetPlansOKApigw = [1]string{
	0: "plans",
}

// Decode decodes GetPlansOKApigw from json.
func (s *GetPlansOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPlansOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "plans":
			if err := func() error {
				s.Plans = make([]Plan, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Plan
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Plans = append(s.Plans, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plans\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPlansOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPlansOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPlansOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRequestTransformationBadRequest as json.
func (s *GetRequestTransformationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRequestTransformationBadRequest from json.
func (s *GetRequestTransformationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRequestTransformationBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRequestTransformationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRequestTransformationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRequestTransformationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRequestTransformationInternalServerError as json.
func (s *GetRequestTransformationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRequestTransformationInternalServerError from json.
func (s *GetRequestTransformationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRequestTransformationInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRequestTransformationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRequestTransformationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRequestTransformationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRequestTransformationNotFound as json.
func (s *GetRequestTransformationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRequestTransformationNotFound from json.
func (s *GetRequestTransformationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRequestTransformationNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRequestTransformationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRequestTransformationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRequestTransformationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRequestTransformationOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRequestTransformationOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetRequestTransformationOK = [1]string{
	0: "apigw",
}

// Decode decodes GetRequestTransformationOK from json.
func (s *GetRequestTransformationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRequestTransformationOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRequestTransformationOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRequestTransformationOK) {
					name = jsonFieldsNameOfGetRequestTransformationOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRequestTransformationOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRequestTransformationOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRequestTransformationOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRequestTransformationOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.RequestTransformation.Set {
			e.FieldStart("requestTransformation")
			s.RequestTransformation.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRequestTransformationOKApigw = [1]string{
	0: "requestTransformation",
}

// Decode decodes GetRequestTransformationOKApigw from json.
func (s *GetRequestTransformationOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRequestTransformationOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "requestTransformation":
			if err := func() error {
				s.RequestTransformation.Reset()
				if err := s.RequestTransformation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestTransformation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRequestTransformationOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRequestTransformationOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRequestTransformationOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRequestTransformationUnauthorized as json.
func (s *GetRequestTransformationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRequestTransformationUnauthorized from json.
func (s *GetRequestTransformationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRequestTransformationUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRequestTransformationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRequestTransformationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRequestTransformationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResponseTransformationBadRequest as json.
func (s *GetResponseTransformationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResponseTransformationBadRequest from json.
func (s *GetResponseTransformationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResponseTransformationBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResponseTransformationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResponseTransformationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResponseTransformationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResponseTransformationInternalServerError as json.
func (s *GetResponseTransformationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResponseTransformationInternalServerError from json.
func (s *GetResponseTransformationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResponseTransformationInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResponseTransformationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResponseTransformationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResponseTransformationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResponseTransformationNotFound as json.
func (s *GetResponseTransformationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResponseTransformationNotFound from json.
func (s *GetResponseTransformationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResponseTransformationNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResponseTransformationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResponseTransformationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResponseTransformationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetResponseTransformationOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetResponseTransformationOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetResponseTransformationOK = [1]string{
	0: "apigw",
}

// Decode decodes GetResponseTransformationOK from json.
func (s *GetResponseTransformationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResponseTransformationOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetResponseTransformationOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetResponseTransformationOK) {
					name = jsonFieldsNameOfGetResponseTransformationOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResponseTransformationOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResponseTransformationOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetResponseTransformationOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetResponseTransformationOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.ResponseTransformation.Set {
			e.FieldStart("responseTransformation")
			s.ResponseTransformation.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetResponseTransformationOKApigw = [1]string{
	0: "responseTransformation",
}

// Decode decodes GetResponseTransformationOKApigw from json.
func (s *GetResponseTransformationOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResponseTransformationOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "responseTransformation":
			if err := func() error {
				s.ResponseTransformation.Reset()
				if err := s.ResponseTransformation.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseTransformation\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetResponseTransformationOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResponseTransformationOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResponseTransformationOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetResponseTransformationUnauthorized as json.
func (s *GetResponseTransformationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetResponseTransformationUnauthorized from json.
func (s *GetResponseTransformationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetResponseTransformationUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetResponseTransformationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetResponseTransformationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetResponseTransformationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRouteAuthorizationBadRequest as json.
func (s *GetRouteAuthorizationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRouteAuthorizationBadRequest from json.
func (s *GetRouteAuthorizationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRouteAuthorizationBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRouteAuthorizationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRouteAuthorizationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRouteAuthorizationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRouteAuthorizationInternalServerError as json.
func (s *GetRouteAuthorizationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRouteAuthorizationInternalServerError from json.
func (s *GetRouteAuthorizationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRouteAuthorizationInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRouteAuthorizationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRouteAuthorizationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRouteAuthorizationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRouteAuthorizationNotFound as json.
func (s *GetRouteAuthorizationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRouteAuthorizationNotFound from json.
func (s *GetRouteAuthorizationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRouteAuthorizationNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRouteAuthorizationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRouteAuthorizationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRouteAuthorizationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRouteAuthorizationOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRouteAuthorizationOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetRouteAuthorizationOK = [1]string{
	0: "apigw",
}

// Decode decodes GetRouteAuthorizationOK from json.
func (s *GetRouteAuthorizationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRouteAuthorizationOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRouteAuthorizationOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRouteAuthorizationOK) {
					name = jsonFieldsNameOfGetRouteAuthorizationOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRouteAuthorizationOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRouteAuthorizationOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRouteAuthorizationOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRouteAuthorizationOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.RouteAuthorization.Set {
			e.FieldStart("routeAuthorization")
			s.RouteAuthorization.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRouteAuthorizationOKApigw = [1]string{
	0: "routeAuthorization",
}

// Decode decodes GetRouteAuthorizationOKApigw from json.
func (s *GetRouteAuthorizationOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRouteAuthorizationOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "routeAuthorization":
			if err := func() error {
				s.RouteAuthorization.Reset()
				if err := s.RouteAuthorization.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"routeAuthorization\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRouteAuthorizationOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRouteAuthorizationOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRouteAuthorizationOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRouteAuthorizationUnauthorized as json.
func (s *GetRouteAuthorizationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRouteAuthorizationUnauthorized from json.
func (s *GetRouteAuthorizationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRouteAuthorizationUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRouteAuthorizationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRouteAuthorizationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRouteAuthorizationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRouteBadRequest as json.
func (s *GetRouteBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRouteBadRequest from json.
func (s *GetRouteBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRouteBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRouteBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRouteBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRouteBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRouteInternalServerError as json.
func (s *GetRouteInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRouteInternalServerError from json.
func (s *GetRouteInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRouteInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRouteInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRouteInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRouteInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRouteNotFound as json.
func (s *GetRouteNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRouteNotFound from json.
func (s *GetRouteNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRouteNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRouteNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRouteNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRouteNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRouteOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRouteOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetRouteOK = [1]string{
	0: "apigw",
}

// Decode decodes GetRouteOK from json.
func (s *GetRouteOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRouteOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRouteOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRouteOK) {
					name = jsonFieldsNameOfGetRouteOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRouteOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRouteOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRouteOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRouteOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Route.Set {
			e.FieldStart("route")
			s.Route.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRouteOKApigw = [1]string{
	0: "route",
}

// Decode decodes GetRouteOKApigw from json.
func (s *GetRouteOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRouteOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "route":
			if err := func() error {
				s.Route.Reset()
				if err := s.Route.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"route\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRouteOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRouteOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRouteOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRouteUnauthorized as json.
func (s *GetRouteUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetRouteUnauthorized from json.
func (s *GetRouteUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRouteUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetRouteUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRouteUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRouteUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServiceByIdBadRequest as json.
func (s *GetServiceByIdBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetServiceByIdBadRequest from json.
func (s *GetServiceByIdBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceByIdBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceByIdBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServiceByIdBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceByIdBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServiceByIdInternalServerError as json.
func (s *GetServiceByIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetServiceByIdInternalServerError from json.
func (s *GetServiceByIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceByIdInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceByIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServiceByIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceByIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServiceByIdNotFound as json.
func (s *GetServiceByIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetServiceByIdNotFound from json.
func (s *GetServiceByIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceByIdNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceByIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServiceByIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceByIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetServiceByIdOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetServiceByIdOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetServiceByIdOK = [1]string{
	0: "apigw",
}

// Decode decodes GetServiceByIdOK from json.
func (s *GetServiceByIdOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceByIdOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetServiceByIdOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetServiceByIdOK) {
					name = jsonFieldsNameOfGetServiceByIdOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServiceByIdOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceByIdOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetServiceByIdOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetServiceByIdOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Service.Set {
			e.FieldStart("service")
			s.Service.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetServiceByIdOKApigw = [1]string{
	0: "service",
}

// Decode decodes GetServiceByIdOKApigw from json.
func (s *GetServiceByIdOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceByIdOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetServiceByIdOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServiceByIdOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceByIdOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServiceRoutesBadRequest as json.
func (s *GetServiceRoutesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetServiceRoutesBadRequest from json.
func (s *GetServiceRoutesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceRoutesBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceRoutesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServiceRoutesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceRoutesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServiceRoutesInternalServerError as json.
func (s *GetServiceRoutesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetServiceRoutesInternalServerError from json.
func (s *GetServiceRoutesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceRoutesInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceRoutesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServiceRoutesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceRoutesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServiceRoutesNotFound as json.
func (s *GetServiceRoutesNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetServiceRoutesNotFound from json.
func (s *GetServiceRoutesNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceRoutesNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceRoutesNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServiceRoutesNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceRoutesNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetServiceRoutesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetServiceRoutesOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetServiceRoutesOK = [1]string{
	0: "apigw",
}

// Decode decodes GetServiceRoutesOK from json.
func (s *GetServiceRoutesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceRoutesOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetServiceRoutesOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetServiceRoutesOK) {
					name = jsonFieldsNameOfGetServiceRoutesOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServiceRoutesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceRoutesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetServiceRoutesOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetServiceRoutesOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Routes != nil {
			e.FieldStart("routes")
			e.ArrStart()
			for _, elem := range s.Routes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetServiceRoutesOKApigw = [1]string{
	0: "routes",
}

// Decode decodes GetServiceRoutesOKApigw from json.
func (s *GetServiceRoutesOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceRoutesOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "routes":
			if err := func() error {
				s.Routes = make([]Route, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Route
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Routes = append(s.Routes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"routes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetServiceRoutesOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServiceRoutesOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceRoutesOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServiceRoutesUnauthorized as json.
func (s *GetServiceRoutesUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetServiceRoutesUnauthorized from json.
func (s *GetServiceRoutesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServiceRoutesUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServiceRoutesUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServiceRoutesUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServiceRoutesUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServicesBadRequest as json.
func (s *GetServicesBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetServicesBadRequest from json.
func (s *GetServicesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServicesBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServicesBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServicesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServicesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServicesInternalServerError as json.
func (s *GetServicesInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetServicesInternalServerError from json.
func (s *GetServicesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServicesInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServicesInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServicesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServicesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetServicesOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetServicesOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetServicesOK = [1]string{
	0: "apigw",
}

// Decode decodes GetServicesOK from json.
func (s *GetServicesOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServicesOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetServicesOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetServicesOK) {
					name = jsonFieldsNameOfGetServicesOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServicesOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServicesOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetServicesOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetServicesOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Services != nil {
			e.FieldStart("services")
			e.ArrStart()
			for _, elem := range s.Services {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetServicesOKApigw = [1]string{
	0: "services",
}

// Decode decodes GetServicesOKApigw from json.
func (s *GetServicesOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServicesOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "services":
			if err := func() error {
				s.Services = make([]ServiceDetailResponse, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ServiceDetailResponse
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Services = append(s.Services, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"services\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetServicesOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServicesOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServicesOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetServicesUnauthorized as json.
func (s *GetServicesUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetServicesUnauthorized from json.
func (s *GetServicesUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetServicesUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetServicesUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetServicesUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetServicesUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionByIdInternalServerError as json.
func (s *GetSubscriptionByIdInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSubscriptionByIdInternalServerError from json.
func (s *GetSubscriptionByIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByIdInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSubscriptionByIdInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionByIdNotFound as json.
func (s *GetSubscriptionByIdNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSubscriptionByIdNotFound from json.
func (s *GetSubscriptionByIdNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByIdNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSubscriptionByIdNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByIdNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByIdNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByIdOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByIdOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionByIdOK = [1]string{
	0: "apigw",
}

// Decode decodes GetSubscriptionByIdOK from json.
func (s *GetSubscriptionByIdOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByIdOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByIdOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByIdOK) {
					name = jsonFieldsNameOfGetSubscriptionByIdOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByIdOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByIdOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByIdOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByIdOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Subscription.Set {
			e.FieldStart("subscription")
			s.Subscription.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetSubscriptionByIdOKApigw = [1]string{
	0: "subscription",
}

// Decode decodes GetSubscriptionByIdOKApigw from json.
func (s *GetSubscriptionByIdOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByIdOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscription":
			if err := func() error {
				s.Subscription.Reset()
				if err := s.Subscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByIdOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByIdOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByIdOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionsInternalServerError as json.
func (s *GetSubscriptionsInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSubscriptionsInternalServerError from json.
func (s *GetSubscriptionsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionsInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSubscriptionsInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionsOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionsOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionsOK = [1]string{
	0: "apigw",
}

// Decode decodes GetSubscriptionsOK from json.
func (s *GetSubscriptionsOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionsOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionsOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionsOK) {
					name = jsonFieldsNameOfGetSubscriptionsOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionsOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionsOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionsUnauthorized as json.
func (s *GetSubscriptionsUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetSubscriptionsUnauthorized from json.
func (s *GetSubscriptionsUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionsUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetSubscriptionsUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionsUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionsUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserAuthenticationBadRequest as json.
func (s *GetUserAuthenticationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUserAuthenticationBadRequest from json.
func (s *GetUserAuthenticationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserAuthenticationBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserAuthenticationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserAuthenticationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserAuthenticationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserAuthenticationInternalServerError as json.
func (s *GetUserAuthenticationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUserAuthenticationInternalServerError from json.
func (s *GetUserAuthenticationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserAuthenticationInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserAuthenticationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserAuthenticationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserAuthenticationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserAuthenticationNotFound as json.
func (s *GetUserAuthenticationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUserAuthenticationNotFound from json.
func (s *GetUserAuthenticationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserAuthenticationNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserAuthenticationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserAuthenticationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserAuthenticationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserAuthenticationOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserAuthenticationOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetUserAuthenticationOK = [1]string{
	0: "apigw",
}

// Decode decodes GetUserAuthenticationOK from json.
func (s *GetUserAuthenticationOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserAuthenticationOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserAuthenticationOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserAuthenticationOK) {
					name = jsonFieldsNameOfGetUserAuthenticationOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserAuthenticationOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserAuthenticationOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserAuthenticationOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserAuthenticationOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.UserAuthentication.Set {
			e.FieldStart("userAuthentication")
			s.UserAuthentication.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetUserAuthenticationOKApigw = [1]string{
	0: "userAuthentication",
}

// Decode decodes GetUserAuthenticationOKApigw from json.
func (s *GetUserAuthenticationOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserAuthenticationOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userAuthentication":
			if err := func() error {
				s.UserAuthentication.Reset()
				if err := s.UserAuthentication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAuthentication\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserAuthenticationOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserAuthenticationOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserAuthenticationOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserAuthenticationUnauthorized as json.
func (s *GetUserAuthenticationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUserAuthenticationUnauthorized from json.
func (s *GetUserAuthenticationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserAuthenticationUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserAuthenticationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserAuthenticationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserAuthenticationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserBadRequest as json.
func (s *GetUserBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUserBadRequest from json.
func (s *GetUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserGroupBadRequest as json.
func (s *GetUserGroupBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUserGroupBadRequest from json.
func (s *GetUserGroupBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserGroupBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserGroupBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserGroupBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserGroupBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserGroupInternalServerError as json.
func (s *GetUserGroupInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUserGroupInternalServerError from json.
func (s *GetUserGroupInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserGroupInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserGroupInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserGroupInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserGroupInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserGroupNotFound as json.
func (s *GetUserGroupNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUserGroupNotFound from json.
func (s *GetUserGroupNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserGroupNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserGroupNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserGroupNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserGroupNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserGroupOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserGroupOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetUserGroupOK = [1]string{
	0: "apigw",
}

// Decode decodes GetUserGroupOK from json.
func (s *GetUserGroupOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserGroupOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserGroupOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserGroupOK) {
					name = jsonFieldsNameOfGetUserGroupOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserGroupOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserGroupOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserGroupOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserGroupOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Groups != nil {
			e.FieldStart("groups")
			e.ArrStart()
			for _, elem := range s.Groups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetUserGroupOKApigw = [1]string{
	0: "groups",
}

// Decode decodes GetUserGroupOKApigw from json.
func (s *GetUserGroupOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserGroupOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "groups":
			if err := func() error {
				s.Groups = make([]UserGroupDetail, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserGroupDetail
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserGroupOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserGroupOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserGroupOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserInternalServerError as json.
func (s *GetUserInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUserInternalServerError from json.
func (s *GetUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserNotFound as json.
func (s *GetUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUserNotFound from json.
func (s *GetUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetUserOK = [1]string{
	0: "apigw",
}

// Decode decodes GetUserOK from json.
func (s *GetUserOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserOK) {
					name = jsonFieldsNameOfGetUserOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetUserOKApigw = [1]string{
	0: "user",
}

// Decode decodes GetUserOKApigw from json.
func (s *GetUserOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserUnauthorized as json.
func (s *GetUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUserUnauthorized from json.
func (s *GetUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUsersBadRequest as json.
func (s *GetUsersBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUsersBadRequest from json.
func (s *GetUsersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUsersBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUsersBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUsersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUsersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUsersInternalServerError as json.
func (s *GetUsersInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUsersInternalServerError from json.
func (s *GetUsersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUsersInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUsersInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUsersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUsersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUsersOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUsersOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apigw")
		s.Apigw.Encode(e)
	}
}

var jsonFieldsNameOfGetUsersOK = [1]string{
	0: "apigw",
}

// Decode decodes GetUsersOK from json.
func (s *GetUsersOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUsersOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apigw":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Apigw.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apigw\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUsersOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUsersOK) {
					name = jsonFieldsNameOfGetUsersOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUsersOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUsersOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUsersOKApigw) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUsersOKApigw) encodeFields(e *jx.Encoder) {
	{
		if s.Users != nil {
			e.FieldStart("users")
			e.ArrStart()
			for _, elem := range s.Users {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetUsersOKApigw = [1]string{
	0: "users",
}

// Decode decodes GetUsersOKApigw from json.
func (s *GetUsersOKApigw) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUsersOKApigw to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			if err := func() error {
				s.Users = make([]User, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem User
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUsersOKApigw")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUsersOKApigw) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUsersOKApigw) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUsersUnauthorized as json.
func (s *GetUsersUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes GetUsersUnauthorized from json.
func (s *GetUsersUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUsersUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUsersUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUsersUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUsersUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Group) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Group) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
}

var jsonFieldsNameOfGroup = [5]string{
	0: "id",
	1: "createdAt",
	2: "updatedAt",
	3: "name",
	4: "tags",
}

// Decode decodes Group from json.
func (s *Group) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Group to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "tags":
			if err := func() error {
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Group")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Group) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Group) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTTPMethod as json.
func (s HTTPMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HTTPMethod from json.
func (s *HTTPMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HTTPMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HTTPMethod(v) {
	case HTTPMethodGET:
		*s = HTTPMethodGET
	case HTTPMethodPOST:
		*s = HTTPMethodPOST
	case HTTPMethodPUT:
		*s = HTTPMethodPUT
	case HTTPMethodDELETE:
		*s = HTTPMethodDELETE
	case HTTPMethodPATCH:
		*s = HTTPMethodPATCH
	case HTTPMethodOPTIONS:
		*s = HTTPMethodOPTIONS
	case HTTPMethodHEAD:
		*s = HTTPMethodHEAD
	case HTTPMethodCONNECT:
		*s = HTTPMethodCONNECT
	case HTTPMethodTRACE:
		*s = HTTPMethodTRACE
	default:
		*s = HTTPMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HTTPMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HTTPMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HmacAuth) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HmacAuth) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("userName")
		e.Str(s.UserName)
	}
	{
		e.FieldStart("secret")
		e.Str(s.Secret)
	}
}

var jsonFieldsNameOfHmacAuth = [5]string{
	0: "id",
	1: "createdAt",
	2: "updatedAt",
	3: "userName",
	4: "secret",
}

// Decode decodes HmacAuth from json.
func (s *HmacAuth) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HmacAuth to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "userName":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.UserName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userName\"")
			}
		case "secret":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Secret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HmacAuth")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHmacAuth) {
					name = jsonFieldsNameOfHmacAuth[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HmacAuth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HmacAuth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IpRestrictionConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IpRestrictionConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("protocols")
		s.Protocols.Encode(e)
	}
	{
		e.FieldStart("restrictedBy")
		s.RestrictedBy.Encode(e)
	}
	{
		e.FieldStart("ips")
		e.ArrStart()
		for _, elem := range s.Ips {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfIpRestrictionConfig = [3]string{
	0: "protocols",
	1: "restrictedBy",
	2: "ips",
}

// Decode decodes IpRestrictionConfig from json.
func (s *IpRestrictionConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IpRestrictionConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "protocols":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Protocols.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocols\"")
			}
		case "restrictedBy":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.RestrictedBy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"restrictedBy\"")
			}
		case "ips":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Ips = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Ips = append(s.Ips, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ips\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IpRestrictionConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIpRestrictionConfig) {
					name = jsonFieldsNameOfIpRestrictionConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IpRestrictionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IpRestrictionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IpRestrictionConfigProtocols as json.
func (s IpRestrictionConfigProtocols) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IpRestrictionConfigProtocols from json.
func (s *IpRestrictionConfigProtocols) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IpRestrictionConfigProtocols to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IpRestrictionConfigProtocols(v) {
	case IpRestrictionConfigProtocolsHTTPHTTPS:
		*s = IpRestrictionConfigProtocolsHTTPHTTPS
	case IpRestrictionConfigProtocolsHTTP:
		*s = IpRestrictionConfigProtocolsHTTP
	case IpRestrictionConfigProtocolsHTTPS:
		*s = IpRestrictionConfigProtocolsHTTPS
	default:
		*s = IpRestrictionConfigProtocols(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IpRestrictionConfigProtocols) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IpRestrictionConfigProtocols) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IpRestrictionConfigRestrictedBy as json.
func (s IpRestrictionConfigRestrictedBy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IpRestrictionConfigRestrictedBy from json.
func (s *IpRestrictionConfigRestrictedBy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IpRestrictionConfigRestrictedBy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IpRestrictionConfigRestrictedBy(v) {
	case IpRestrictionConfigRestrictedByAllowIps:
		*s = IpRestrictionConfigRestrictedByAllowIps
	case IpRestrictionConfigRestrictedByDenyIps:
		*s = IpRestrictionConfigRestrictedByDenyIps
	default:
		*s = IpRestrictionConfigRestrictedBy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IpRestrictionConfigRestrictedBy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IpRestrictionConfigRestrictedBy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JSONKey as json.
func (s JSONKey) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes JSONKey from json.
func (s *JSONKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JSONKey to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = JSONKey(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JSONKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JSONKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Jwt) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Jwt) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("secret")
		e.Str(s.Secret)
	}
	{
		e.FieldStart("algorithm")
		s.Algorithm.Encode(e)
	}
}

var jsonFieldsNameOfJwt = [6]string{
	0: "id",
	1: "createdAt",
	2: "updatedAt",
	3: "key",
	4: "secret",
	5: "algorithm",
}

// Decode decodes Jwt from json.
func (s *Jwt) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Jwt to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "secret":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Secret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secret\"")
			}
		case "algorithm":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Algorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"algorithm\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Jwt")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00101000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfJwt) {
					name = jsonFieldsNameOfJwt[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Jwt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Jwt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JwtAlgorithm as json.
func (s JwtAlgorithm) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes JwtAlgorithm from json.
func (s *JwtAlgorithm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode JwtAlgorithm to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch JwtAlgorithm(v) {
	case JwtAlgorithmHS256:
		*s = JwtAlgorithmHS256
	case JwtAlgorithmHS384:
		*s = JwtAlgorithmHS384
	case JwtAlgorithmHS512:
		*s = JwtAlgorithmHS512
	default:
		*s = JwtAlgorithm(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s JwtAlgorithm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *JwtAlgorithm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Name as json.
func (s Name) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes Name from json.
func (s *Name) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Name to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Name(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Name) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Name) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectStorageConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectStorageConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("bucketName")
		e.Str(s.BucketName)
	}
	{
		if s.FolderName.Set {
			e.FieldStart("folderName")
			s.FolderName.Encode(e)
		}
	}
	{
		e.FieldStart("endpoint")
		e.Str(s.Endpoint)
	}
	{
		e.FieldStart("region")
		e.Str(s.Region)
	}
	{
		e.FieldStart("accessKeyID")
		e.Str(s.AccessKeyID)
	}
	{
		e.FieldStart("secretAccessKey")
		e.Str(s.SecretAccessKey)
	}
	{
		e.FieldStart("useDocumentIndex")
		e.Bool(s.UseDocumentIndex)
	}
}

var jsonFieldsNameOfObjectStorageConfig = [7]string{
	0: "bucketName",
	1: "folderName",
	2: "endpoint",
	3: "region",
	4: "accessKeyID",
	5: "secretAccessKey",
	6: "useDocumentIndex",
}

// Decode decodes ObjectStorageConfig from json.
func (s *ObjectStorageConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectStorageConfig to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bucketName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.BucketName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bucketName\"")
			}
		case "folderName":
			if err := func() error {
				s.FolderName.Reset()
				if err := s.FolderName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"folderName\"")
			}
		case "endpoint":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Endpoint = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"endpoint\"")
			}
		case "region":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Region = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"region\"")
			}
		case "accessKeyID":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.AccessKeyID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessKeyID\"")
			}
		case "secretAccessKey":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.SecretAccessKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secretAccessKey\"")
			}
		case "useDocumentIndex":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.UseDocumentIndex = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"useDocumentIndex\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ObjectStorageConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfObjectStorageConfig) {
					name = jsonFieldsNameOfObjectStorageConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectStorageConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectStorageConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Oidc) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Oidc) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("authenticationMethods")
		s.AuthenticationMethods.Encode(e)
	}
	{
		e.FieldStart("issuer")
		e.Str(s.Issuer)
	}
	{
		e.FieldStart("clientId")
		e.Str(s.ClientId)
	}
	{
		e.FieldStart("clientSecret")
		e.Str(s.ClientSecret)
	}
	{
		if s.Scopes != nil {
			e.FieldStart("scopes")
			e.ArrStart()
			for _, elem := range s.Scopes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HideCredentials.Set {
			e.FieldStart("hideCredentials")
			s.HideCredentials.Encode(e)
		}
	}
	{
		if s.TokenAudiences != nil {
			e.FieldStart("tokenAudiences")
			e.ArrStart()
			for _, elem := range s.TokenAudiences {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.UseSession.Set {
			e.FieldStart("useSession")
			s.UseSession.Encode(e)
		}
	}
	{
		if s.RefreshTokenParamName.Set {
			e.FieldStart("refreshTokenParamName")
			s.RefreshTokenParamName.Encode(e)
		}
	}
}

var jsonFieldsNameOfOidc = [13]string{
	0:  "id",
	1:  "createdAt",
	2:  "updatedAt",
	3:  "name",
	4:  "authenticationMethods",
	5:  "issuer",
	6:  "clientId",
	7:  "clientSecret",
	8:  "scopes",
	9:  "hideCredentials",
	10: "tokenAudiences",
	11: "useSession",
	12: "refreshTokenParamName",
}

// Decode decodes Oidc from json.
func (s *Oidc) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Oidc to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "authenticationMethods":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.AuthenticationMethods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authenticationMethods\"")
			}
		case "issuer":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Issuer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issuer\"")
			}
		case "clientId":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ClientId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "clientSecret":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ClientSecret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientSecret\"")
			}
		case "scopes":
			if err := func() error {
				s.Scopes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Scopes = append(s.Scopes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "hideCredentials":
			if err := func() error {
				s.HideCredentials.Reset()
				if err := s.HideCredentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hideCredentials\"")
			}
		case "tokenAudiences":
			if err := func() error {
				s.TokenAudiences = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TokenAudiences = append(s.TokenAudiences, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenAudiences\"")
			}
		case "useSession":
			if err := func() error {
				s.UseSession.Reset()
				if err := s.UseSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"useSession\"")
			}
		case "refreshTokenParamName":
			if err := func() error {
				s.RefreshTokenParamName.Reset()
				if err := s.RefreshTokenParamName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refreshTokenParamName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Oidc")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOidc) {
					name = jsonFieldsNameOfOidc[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Oidc) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Oidc) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OidcDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OidcDetail) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("authenticationMethods")
		s.AuthenticationMethods.Encode(e)
	}
	{
		e.FieldStart("issuer")
		e.Str(s.Issuer)
	}
	{
		e.FieldStart("clientId")
		e.Str(s.ClientId)
	}
	{
		e.FieldStart("clientSecret")
		e.Str(s.ClientSecret)
	}
	{
		if s.Scopes != nil {
			e.FieldStart("scopes")
			e.ArrStart()
			for _, elem := range s.Scopes {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HideCredentials.Set {
			e.FieldStart("hideCredentials")
			s.HideCredentials.Encode(e)
		}
	}
	{
		if s.TokenAudiences != nil {
			e.FieldStart("tokenAudiences")
			e.ArrStart()
			for _, elem := range s.TokenAudiences {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.UseSession.Set {
			e.FieldStart("useSession")
			s.UseSession.Encode(e)
		}
	}
	{
		if s.RefreshTokenParamName.Set {
			e.FieldStart("refreshTokenParamName")
			s.RefreshTokenParamName.Encode(e)
		}
	}
	{
		if s.Services != nil {
			e.FieldStart("services")
			e.ArrStart()
			for _, elem := range s.Services {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfOidcDetail = [14]string{
	0:  "id",
	1:  "createdAt",
	2:  "updatedAt",
	3:  "name",
	4:  "authenticationMethods",
	5:  "issuer",
	6:  "clientId",
	7:  "clientSecret",
	8:  "scopes",
	9:  "hideCredentials",
	10: "tokenAudiences",
	11: "useSession",
	12: "refreshTokenParamName",
	13: "services",
}

// Decode decodes OidcDetail from json.
func (s *OidcDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OidcDetail to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "authenticationMethods":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.AuthenticationMethods.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authenticationMethods\"")
			}
		case "issuer":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Issuer = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issuer\"")
			}
		case "clientId":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ClientId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "clientSecret":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.ClientSecret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientSecret\"")
			}
		case "scopes":
			if err := func() error {
				s.Scopes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Scopes = append(s.Scopes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		case "hideCredentials":
			if err := func() error {
				s.HideCredentials.Reset()
				if err := s.HideCredentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hideCredentials\"")
			}
		case "tokenAudiences":
			if err := func() error {
				s.TokenAudiences = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.TokenAudiences = append(s.TokenAudiences, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenAudiences\"")
			}
		case "useSession":
			if err := func() error {
				s.UseSession.Reset()
				if err := s.UseSession.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"useSession\"")
			}
		case "refreshTokenParamName":
			if err := func() error {
				s.RefreshTokenParamName.Reset()
				if err := s.RefreshTokenParamName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refreshTokenParamName\"")
			}
		case "services":
			if err := func() error {
				s.Services = make([]ServiceSummary, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ServiceSummary
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Services = append(s.Services, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"services\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OidcDetail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOidcDetail) {
					name = jsonFieldsNameOfOidcDetail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OidcDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OidcDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OidcSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OidcSummary) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfOidcSummary = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes OidcSummary from json.
func (s *OidcSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OidcSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OidcSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OidcSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OidcSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BasicAuth as json.
func (o OptBasicAuth) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes BasicAuth from json.
func (o *OptBasicAuth) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBasicAuth to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBasicAuth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBasicAuth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Certificate as json.
func (o OptCertificate) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Certificate from json.
func (o *OptCertificate) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCertificate to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCertificate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCertificate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CertificateDetails as json.
func (o OptCertificateDetails) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CertificateDetails from json.
func (o *OptCertificateDetails) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCertificateDetails to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCertificateDetails) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCertificateDetails) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CorsConfig as json.
func (o OptCorsConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CorsConfig from json.
func (o *OptCorsConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCorsConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCorsConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCorsConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes Domain as json.
func (o OptDomain) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Domain from json.
func (o *OptDomain) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDomain to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDomain) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDomain) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Group as json.
func (o OptGroup) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Group from json.
func (o *OptGroup) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGroup to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGroup) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGroup) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HTTPMethod as json.
func (o OptHTTPMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HTTPMethod from json.
func (o *OptHTTPMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHTTPMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHTTPMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHTTPMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HmacAuth as json.
func (o OptHmacAuth) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HmacAuth from json.
func (o *OptHmacAuth) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHmacAuth to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHmacAuth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHmacAuth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IpRestrictionConfig as json.
func (o OptIpRestrictionConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IpRestrictionConfig from json.
func (o *OptIpRestrictionConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIpRestrictionConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIpRestrictionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIpRestrictionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes JSONKey as json.
func (o OptJSONKey) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes JSONKey from json.
func (o *OptJSONKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJSONKey to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJSONKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJSONKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Jwt as json.
func (o OptJwt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Jwt from json.
func (o *OptJwt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptJwt to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptJwt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptJwt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Name as json.
func (o OptName) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Name from json.
func (o *OptName) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptName to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptName) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptName) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ObjectStorageConfig as json.
func (o OptObjectStorageConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ObjectStorageConfig from json.
func (o *OptObjectStorageConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptObjectStorageConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptObjectStorageConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptObjectStorageConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Oidc as json.
func (o OptOidc) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Oidc from json.
func (o *OptOidc) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOidc to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOidc) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOidc) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OidcDetail as json.
func (o OptOidcDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OidcDetail from json.
func (o *OptOidcDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOidcDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOidcDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOidcDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OidcSummary as json.
func (o OptOidcSummary) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes OidcSummary from json.
func (o *OptOidcSummary) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOidcSummary to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOidcSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOidcSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Overage as json.
func (o OptOverage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Overage from json.
func (o *OptOverage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptOverage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptOverage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptOverage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlanMaxRequestsUnit as json.
func (o OptPlanMaxRequestsUnit) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes PlanMaxRequestsUnit from json.
func (o *OptPlanMaxRequestsUnit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPlanMaxRequestsUnit to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPlanMaxRequestsUnit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPlanMaxRequestsUnit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QueryParamKey as json.
func (o OptQueryParamKey) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes QueryParamKey from json.
func (o *OptQueryParamKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQueryParamKey to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQueryParamKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQueryParamKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QueryParamValue as json.
func (o OptQueryParamValue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes QueryParamValue from json.
func (o *OptQueryParamValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptQueryParamValue to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptQueryParamValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptQueryParamValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestAllowDetail as json.
func (o OptRequestAllowDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RequestAllowDetail from json.
func (o *OptRequestAllowDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRequestAllowDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRequestAllowDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRequestAllowDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestHeaderKey as json.
func (o OptRequestHeaderKey) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RequestHeaderKey from json.
func (o *OptRequestHeaderKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRequestHeaderKey to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRequestHeaderKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRequestHeaderKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestHeaderValue as json.
func (o OptRequestHeaderValue) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RequestHeaderValue from json.
func (o *OptRequestHeaderValue) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRequestHeaderValue to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRequestHeaderValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRequestHeaderValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestModificationDetail as json.
func (o OptRequestModificationDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RequestModificationDetail from json.
func (o *OptRequestModificationDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRequestModificationDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRequestModificationDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRequestModificationDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestRemoveDetail as json.
func (o OptRequestRemoveDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RequestRemoveDetail from json.
func (o *OptRequestRemoveDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRequestRemoveDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRequestRemoveDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRequestRemoveDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestRenameDetail as json.
func (o OptRequestRenameDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RequestRenameDetail from json.
func (o *OptRequestRenameDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRequestRenameDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRequestRenameDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRequestRenameDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestTransformation as json.
func (o OptRequestTransformation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RequestTransformation from json.
func (o *OptRequestTransformation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRequestTransformation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRequestTransformation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRequestTransformation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponseAllowDetail as json.
func (o OptResponseAllowDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResponseAllowDetail from json.
func (o *OptResponseAllowDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResponseAllowDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResponseAllowDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResponseAllowDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponseHeaderKey as json.
func (o OptResponseHeaderKey) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResponseHeaderKey from json.
func (o *OptResponseHeaderKey) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResponseHeaderKey to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResponseHeaderKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResponseHeaderKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponseModificationDetail as json.
func (o OptResponseModificationDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResponseModificationDetail from json.
func (o *OptResponseModificationDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResponseModificationDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResponseModificationDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResponseModificationDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponseRemoveDetail as json.
func (o OptResponseRemoveDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResponseRemoveDetail from json.
func (o *OptResponseRemoveDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResponseRemoveDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResponseRemoveDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResponseRemoveDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponseRenameDetail as json.
func (o OptResponseRenameDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResponseRenameDetail from json.
func (o *OptResponseRenameDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResponseRenameDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResponseRenameDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResponseRenameDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponseReplaceDetail as json.
func (o OptResponseReplaceDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResponseReplaceDetail from json.
func (o *OptResponseReplaceDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResponseReplaceDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResponseReplaceDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResponseReplaceDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponseTransformation as json.
func (o OptResponseTransformation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResponseTransformation from json.
func (o *OptResponseTransformation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResponseTransformation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResponseTransformation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResponseTransformation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RouteAuthorizationDetail as json.
func (o OptRouteAuthorizationDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RouteAuthorizationDetail from json.
func (o *OptRouteAuthorizationDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRouteAuthorizationDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRouteAuthorizationDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRouteAuthorizationDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RouteAuthorizationDetailResponse as json.
func (o OptRouteAuthorizationDetailResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RouteAuthorizationDetailResponse from json.
func (o *OptRouteAuthorizationDetailResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRouteAuthorizationDetailResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRouteAuthorizationDetailResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRouteAuthorizationDetailResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RouteDetail as json.
func (o OptRouteDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RouteDetail from json.
func (o *OptRouteDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRouteDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRouteDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRouteDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RouteDetailHttpsRedirectStatusCode as json.
func (o OptRouteDetailHttpsRedirectStatusCode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes RouteDetailHttpsRedirectStatusCode from json.
func (o *OptRouteDetailHttpsRedirectStatusCode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRouteDetailHttpsRedirectStatusCode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRouteDetailHttpsRedirectStatusCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRouteDetailHttpsRedirectStatusCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RouteDetailProtocols as json.
func (o OptRouteDetailProtocols) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RouteDetailProtocols from json.
func (o *OptRouteDetailProtocols) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRouteDetailProtocols to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRouteDetailProtocols) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRouteDetailProtocols) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RouteHttpsRedirectStatusCode as json.
func (o OptRouteHttpsRedirectStatusCode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes RouteHttpsRedirectStatusCode from json.
func (o *OptRouteHttpsRedirectStatusCode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRouteHttpsRedirectStatusCode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRouteHttpsRedirectStatusCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRouteHttpsRedirectStatusCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RouteProtocols as json.
func (o OptRouteProtocols) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RouteProtocols from json.
func (o *OptRouteProtocols) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRouteProtocols to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRouteProtocols) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRouteProtocols) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceDetailAuthentication as json.
func (o OptServiceDetailAuthentication) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ServiceDetailAuthentication from json.
func (o *OptServiceDetailAuthentication) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptServiceDetailAuthentication to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptServiceDetailAuthentication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptServiceDetailAuthentication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceDetailRequest as json.
func (o OptServiceDetailRequest) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ServiceDetailRequest from json.
func (o *OptServiceDetailRequest) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptServiceDetailRequest to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptServiceDetailRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptServiceDetailRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceDetailRequestAuthentication as json.
func (o OptServiceDetailRequestAuthentication) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ServiceDetailRequestAuthentication from json.
func (o *OptServiceDetailRequestAuthentication) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptServiceDetailRequestAuthentication to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptServiceDetailRequestAuthentication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptServiceDetailRequestAuthentication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceDetailResponse as json.
func (o OptServiceDetailResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ServiceDetailResponse from json.
func (o *OptServiceDetailResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptServiceDetailResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptServiceDetailResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptServiceDetailResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceDetailResponseAuthentication as json.
func (o OptServiceDetailResponseAuthentication) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ServiceDetailResponseAuthentication from json.
func (o *OptServiceDetailResponseAuthentication) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptServiceDetailResponseAuthentication to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptServiceDetailResponseAuthentication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptServiceDetailResponseAuthentication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubscriptionDetailResponse as json.
func (o OptSubscriptionDetailResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SubscriptionDetailResponse from json.
func (o *OptSubscriptionDetailResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSubscriptionDetailResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSubscriptionDetailResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSubscriptionDetailResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubscriptionPlanResponse as json.
func (o OptSubscriptionPlanResponse) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SubscriptionPlanResponse from json.
func (o *OptSubscriptionPlanResponse) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSubscriptionPlanResponse to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSubscriptionPlanResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSubscriptionPlanResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubscriptionPlanResponseMaxRequestsUnit as json.
func (o OptSubscriptionPlanResponseMaxRequestsUnit) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SubscriptionPlanResponseMaxRequestsUnit from json.
func (o *OptSubscriptionPlanResponseMaxRequestsUnit) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSubscriptionPlanResponseMaxRequestsUnit to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSubscriptionPlanResponseMaxRequestsUnit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSubscriptionPlanResponseMaxRequestsUnit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubscriptionService as json.
func (o OptSubscriptionService) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SubscriptionService from json.
func (o *OptSubscriptionService) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSubscriptionService to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSubscriptionService) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSubscriptionService) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserAuthentication as json.
func (o OptUserAuthentication) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserAuthentication from json.
func (o *OptUserAuthentication) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserAuthentication to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserAuthentication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserAuthentication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserDetail as json.
func (o OptUserDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserDetail from json.
func (o *OptUserDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Overage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Overage) encodeFields(e *jx.Encoder) {
	{
		if s.UnitRequests.Set {
			e.FieldStart("unitRequests")
			s.UnitRequests.Encode(e)
		}
	}
	{
		if s.UnitPrice.Set {
			e.FieldStart("unitPrice")
			s.UnitPrice.Encode(e)
		}
	}
}

var jsonFieldsNameOfOverage = [2]string{
	0: "unitRequests",
	1: "unitPrice",
}

// Decode decodes Overage from json.
func (s *Overage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Overage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "unitRequests":
			if err := func() error {
				s.UnitRequests.Reset()
				if err := s.UnitRequests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unitRequests\"")
			}
		case "unitPrice":
			if err := func() error {
				s.UnitPrice.Reset()
				if err := s.UnitPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"unitPrice\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Overage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Overage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Overage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Plan) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Plan) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.MaxServices.Set {
			e.FieldStart("maxServices")
			s.MaxServices.Encode(e)
		}
	}
	{
		if s.MaxRequests.Set {
			e.FieldStart("maxRequests")
			s.MaxRequests.Encode(e)
		}
	}
	{
		if s.MaxRequestsUnit.Set {
			e.FieldStart("maxRequestsUnit")
			s.MaxRequestsUnit.Encode(e)
		}
	}
	{
		if s.Overage.Set {
			e.FieldStart("overage")
			s.Overage.Encode(e)
		}
	}
}

var jsonFieldsNameOfPlan = [10]string{
	0: "id",
	1: "createdAt",
	2: "updatedAt",
	3: "name",
	4: "price",
	5: "description",
	6: "maxServices",
	7: "maxRequests",
	8: "maxRequestsUnit",
	9: "overage",
}

// Decode decodes Plan from json.
func (s *Plan) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Plan to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "maxServices":
			if err := func() error {
				s.MaxServices.Reset()
				if err := s.MaxServices.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxServices\"")
			}
		case "maxRequests":
			if err := func() error {
				s.MaxRequests.Reset()
				if err := s.MaxRequests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxRequests\"")
			}
		case "maxRequestsUnit":
			if err := func() error {
				s.MaxRequestsUnit.Reset()
				if err := s.MaxRequestsUnit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxRequestsUnit\"")
			}
		case "overage":
			if err := func() error {
				s.Overage.Reset()
				if err := s.Overage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Plan")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Plan) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Plan) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PlanMaxRequestsUnit as json.
func (s PlanMaxRequestsUnit) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes PlanMaxRequestsUnit from json.
func (s *PlanMaxRequestsUnit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PlanMaxRequestsUnit to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch PlanMaxRequestsUnit(v) {
	case PlanMaxRequestsUnitSecond:
		*s = PlanMaxRequestsUnitSecond
	case PlanMaxRequestsUnitMinute:
		*s = PlanMaxRequestsUnitMinute
	case PlanMaxRequestsUnitHour:
		*s = PlanMaxRequestsUnitHour
	case PlanMaxRequestsUnitDay:
		*s = PlanMaxRequestsUnitDay
	case PlanMaxRequestsUnitMonth:
		*s = PlanMaxRequestsUnitMonth
	case PlanMaxRequestsUnitYear:
		*s = PlanMaxRequestsUnitYear
	default:
		*s = PlanMaxRequestsUnit(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s PlanMaxRequestsUnit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PlanMaxRequestsUnit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QueryParamKey as json.
func (s QueryParamKey) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes QueryParamKey from json.
func (s *QueryParamKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryParamKey to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = QueryParamKey(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s QueryParamKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryParamKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes QueryParamValue as json.
func (s QueryParamValue) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes QueryParamValue from json.
func (s *QueryParamValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode QueryParamValue to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = QueryParamValue(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s QueryParamValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *QueryParamValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RequestAllowDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RequestAllowDetail) encodeFields(e *jx.Encoder) {
	{
		if s.Body != nil {
			e.FieldStart("body")
			e.ArrStart()
			for _, elem := range s.Body {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRequestAllowDetail = [1]string{
	0: "body",
}

// Decode decodes RequestAllowDetail from json.
func (s *RequestAllowDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestAllowDetail to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			if err := func() error {
				s.Body = make([]JSONKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem JSONKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Body = append(s.Body, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestAllowDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RequestAllowDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestAllowDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestHeaderKey as json.
func (s RequestHeaderKey) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes RequestHeaderKey from json.
func (s *RequestHeaderKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestHeaderKey to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RequestHeaderKey(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RequestHeaderKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestHeaderKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RequestHeaderValue as json.
func (s RequestHeaderValue) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes RequestHeaderValue from json.
func (s *RequestHeaderValue) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestHeaderValue to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RequestHeaderValue(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RequestHeaderValue) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestHeaderValue) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RequestModificationDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RequestModificationDetail) encodeFields(e *jx.Encoder) {
	{
		if s.Headers != nil {
			e.FieldStart("headers")
			e.ArrStart()
			for _, elem := range s.Headers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.QueryParams != nil {
			e.FieldStart("queryParams")
			e.ArrStart()
			for _, elem := range s.QueryParams {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Body != nil {
			e.FieldStart("body")
			e.ArrStart()
			for _, elem := range s.Body {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRequestModificationDetail = [3]string{
	0: "headers",
	1: "queryParams",
	2: "body",
}

// Decode decodes RequestModificationDetail from json.
func (s *RequestModificationDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestModificationDetail to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			if err := func() error {
				s.Headers = make([]RequestModificationDetailHeadersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RequestModificationDetailHeadersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Headers = append(s.Headers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "queryParams":
			if err := func() error {
				s.QueryParams = make([]RequestModificationDetailQueryParamsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RequestModificationDetailQueryParamsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.QueryParams = append(s.QueryParams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queryParams\"")
			}
		case "body":
			if err := func() error {
				s.Body = make([]RequestModificationDetailBodyItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RequestModificationDetailBodyItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Body = append(s.Body, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestModificationDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RequestModificationDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestModificationDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RequestModificationDetailBodyItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RequestModificationDetailBodyItem) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfRequestModificationDetailBodyItem = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes RequestModificationDetailBodyItem from json.
func (s *RequestModificationDetailBodyItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestModificationDetailBodyItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestModificationDetailBodyItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RequestModificationDetailBodyItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestModificationDetailBodyItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RequestModificationDetailHeadersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RequestModificationDetailHeadersItem) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfRequestModificationDetailHeadersItem = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes RequestModificationDetailHeadersItem from json.
func (s *RequestModificationDetailHeadersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestModificationDetailHeadersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestModificationDetailHeadersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RequestModificationDetailHeadersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestModificationDetailHeadersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RequestModificationDetailQueryParamsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RequestModificationDetailQueryParamsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfRequestModificationDetailQueryParamsItem = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes RequestModificationDetailQueryParamsItem from json.
func (s *RequestModificationDetailQueryParamsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestModificationDetailQueryParamsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestModificationDetailQueryParamsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RequestModificationDetailQueryParamsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestModificationDetailQueryParamsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RequestRemoveDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RequestRemoveDetail) encodeFields(e *jx.Encoder) {
	{
		if s.HeaderKeys != nil {
			e.FieldStart("headerKeys")
			e.ArrStart()
			for _, elem := range s.HeaderKeys {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.QueryParams != nil {
			e.FieldStart("queryParams")
			e.ArrStart()
			for _, elem := range s.QueryParams {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Body != nil {
			e.FieldStart("body")
			e.ArrStart()
			for _, elem := range s.Body {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRequestRemoveDetail = [3]string{
	0: "headerKeys",
	1: "queryParams",
	2: "body",
}

// Decode decodes RequestRemoveDetail from json.
func (s *RequestRemoveDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestRemoveDetail to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headerKeys":
			if err := func() error {
				s.HeaderKeys = make([]RequestHeaderKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RequestHeaderKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HeaderKeys = append(s.HeaderKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headerKeys\"")
			}
		case "queryParams":
			if err := func() error {
				s.QueryParams = make([]QueryParamKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem QueryParamKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.QueryParams = append(s.QueryParams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queryParams\"")
			}
		case "body":
			if err := func() error {
				s.Body = make([]JSONKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem JSONKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Body = append(s.Body, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestRemoveDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RequestRemoveDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestRemoveDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RequestRenameDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RequestRenameDetail) encodeFields(e *jx.Encoder) {
	{
		if s.Headers != nil {
			e.FieldStart("headers")
			e.ArrStart()
			for _, elem := range s.Headers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.QueryParams != nil {
			e.FieldStart("queryParams")
			e.ArrStart()
			for _, elem := range s.QueryParams {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Body != nil {
			e.FieldStart("body")
			e.ArrStart()
			for _, elem := range s.Body {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRequestRenameDetail = [3]string{
	0: "headers",
	1: "queryParams",
	2: "body",
}

// Decode decodes RequestRenameDetail from json.
func (s *RequestRenameDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestRenameDetail to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			if err := func() error {
				s.Headers = make([]RequestRenameDetailHeadersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RequestRenameDetailHeadersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Headers = append(s.Headers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "queryParams":
			if err := func() error {
				s.QueryParams = make([]RequestRenameDetailQueryParamsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RequestRenameDetailQueryParamsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.QueryParams = append(s.QueryParams, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queryParams\"")
			}
		case "body":
			if err := func() error {
				s.Body = make([]RequestRenameDetailBodyItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RequestRenameDetailBodyItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Body = append(s.Body, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestRenameDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RequestRenameDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestRenameDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RequestRenameDetailBodyItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RequestRenameDetailBodyItem) encodeFields(e *jx.Encoder) {
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e)
		}
	}
}

var jsonFieldsNameOfRequestRenameDetailBodyItem = [2]string{
	0: "from",
	1: "to",
}

// Decode decodes RequestRenameDetailBodyItem from json.
func (s *RequestRenameDetailBodyItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestRenameDetailBodyItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestRenameDetailBodyItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RequestRenameDetailBodyItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestRenameDetailBodyItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RequestRenameDetailHeadersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RequestRenameDetailHeadersItem) encodeFields(e *jx.Encoder) {
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e)
		}
	}
}

var jsonFieldsNameOfRequestRenameDetailHeadersItem = [2]string{
	0: "from",
	1: "to",
}

// Decode decodes RequestRenameDetailHeadersItem from json.
func (s *RequestRenameDetailHeadersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestRenameDetailHeadersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestRenameDetailHeadersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RequestRenameDetailHeadersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestRenameDetailHeadersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RequestRenameDetailQueryParamsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RequestRenameDetailQueryParamsItem) encodeFields(e *jx.Encoder) {
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e)
		}
	}
}

var jsonFieldsNameOfRequestRenameDetailQueryParamsItem = [2]string{
	0: "from",
	1: "to",
}

// Decode decodes RequestRenameDetailQueryParamsItem from json.
func (s *RequestRenameDetailQueryParamsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestRenameDetailQueryParamsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestRenameDetailQueryParamsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RequestRenameDetailQueryParamsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestRenameDetailQueryParamsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RequestTransformation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RequestTransformation) encodeFields(e *jx.Encoder) {
	{
		if s.HttpMethod.Set {
			e.FieldStart("httpMethod")
			s.HttpMethod.Encode(e)
		}
	}
	{
		if s.Allow.Set {
			e.FieldStart("allow")
			s.Allow.Encode(e)
		}
	}
	{
		if s.Remove.Set {
			e.FieldStart("remove")
			s.Remove.Encode(e)
		}
	}
	{
		if s.Rename.Set {
			e.FieldStart("rename")
			s.Rename.Encode(e)
		}
	}
	{
		if s.Replace.Set {
			e.FieldStart("replace")
			s.Replace.Encode(e)
		}
	}
	{
		if s.Add.Set {
			e.FieldStart("add")
			s.Add.Encode(e)
		}
	}
	{
		if s.Append.Set {
			e.FieldStart("append")
			s.Append.Encode(e)
		}
	}
}

var jsonFieldsNameOfRequestTransformation = [7]string{
	0: "httpMethod",
	1: "allow",
	2: "remove",
	3: "rename",
	4: "replace",
	5: "add",
	6: "append",
}

// Decode decodes RequestTransformation from json.
func (s *RequestTransformation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RequestTransformation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "httpMethod":
			if err := func() error {
				s.HttpMethod.Reset()
				if err := s.HttpMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpMethod\"")
			}
		case "allow":
			if err := func() error {
				s.Allow.Reset()
				if err := s.Allow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow\"")
			}
		case "remove":
			if err := func() error {
				s.Remove.Reset()
				if err := s.Remove.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove\"")
			}
		case "rename":
			if err := func() error {
				s.Rename.Reset()
				if err := s.Rename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rename\"")
			}
		case "replace":
			if err := func() error {
				s.Replace.Reset()
				if err := s.Replace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replace\"")
			}
		case "add":
			if err := func() error {
				s.Add.Reset()
				if err := s.Add.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add\"")
			}
		case "append":
			if err := func() error {
				s.Append.Reset()
				if err := s.Append.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"append\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RequestTransformation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RequestTransformation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RequestTransformation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseAllowDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseAllowDetail) encodeFields(e *jx.Encoder) {
	{
		if s.JsonKeys != nil {
			e.FieldStart("jsonKeys")
			e.ArrStart()
			for _, elem := range s.JsonKeys {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfResponseAllowDetail = [1]string{
	0: "jsonKeys",
}

// Decode decodes ResponseAllowDetail from json.
func (s *ResponseAllowDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseAllowDetail to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "jsonKeys":
			if err := func() error {
				s.JsonKeys = make([]JSONKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem JSONKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.JsonKeys = append(s.JsonKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jsonKeys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseAllowDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseAllowDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseAllowDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResponseHeaderKey as json.
func (s ResponseHeaderKey) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes ResponseHeaderKey from json.
func (s *ResponseHeaderKey) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseHeaderKey to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ResponseHeaderKey(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResponseHeaderKey) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseHeaderKey) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseModificationDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseModificationDetail) encodeFields(e *jx.Encoder) {
	{
		if s.IfStatusCode != nil {
			e.FieldStart("ifStatusCode")
			e.ArrStart()
			for _, elem := range s.IfStatusCode {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Headers != nil {
			e.FieldStart("headers")
			e.ArrStart()
			for _, elem := range s.Headers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.JSON != nil {
			e.FieldStart("json")
			e.ArrStart()
			for _, elem := range s.JSON {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfResponseModificationDetail = [3]string{
	0: "ifStatusCode",
	1: "headers",
	2: "json",
}

// Decode decodes ResponseModificationDetail from json.
func (s *ResponseModificationDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseModificationDetail to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ifStatusCode":
			if err := func() error {
				s.IfStatusCode = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.IfStatusCode = append(s.IfStatusCode, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ifStatusCode\"")
			}
		case "headers":
			if err := func() error {
				s.Headers = make([]ResponseModificationDetailHeadersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResponseModificationDetailHeadersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Headers = append(s.Headers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "json":
			if err := func() error {
				s.JSON = make([]ResponseModificationDetailJSONItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResponseModificationDetailJSONItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.JSON = append(s.JSON, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"json\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseModificationDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseModificationDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseModificationDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseModificationDetailHeadersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseModificationDetailHeadersItem) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfResponseModificationDetailHeadersItem = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes ResponseModificationDetailHeadersItem from json.
func (s *ResponseModificationDetailHeadersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseModificationDetailHeadersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseModificationDetailHeadersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseModificationDetailHeadersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseModificationDetailHeadersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseModificationDetailJSONItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseModificationDetailJSONItem) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfResponseModificationDetailJSONItem = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes ResponseModificationDetailJSONItem from json.
func (s *ResponseModificationDetailJSONItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseModificationDetailJSONItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseModificationDetailJSONItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseModificationDetailJSONItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseModificationDetailJSONItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseRemoveDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseRemoveDetail) encodeFields(e *jx.Encoder) {
	{
		if s.IfStatusCode != nil {
			e.FieldStart("ifStatusCode")
			e.ArrStart()
			for _, elem := range s.IfStatusCode {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HeaderKeys != nil {
			e.FieldStart("headerKeys")
			e.ArrStart()
			for _, elem := range s.HeaderKeys {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.JsonKeys != nil {
			e.FieldStart("jsonKeys")
			e.ArrStart()
			for _, elem := range s.JsonKeys {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfResponseRemoveDetail = [3]string{
	0: "ifStatusCode",
	1: "headerKeys",
	2: "jsonKeys",
}

// Decode decodes ResponseRemoveDetail from json.
func (s *ResponseRemoveDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseRemoveDetail to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ifStatusCode":
			if err := func() error {
				s.IfStatusCode = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.IfStatusCode = append(s.IfStatusCode, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ifStatusCode\"")
			}
		case "headerKeys":
			if err := func() error {
				s.HeaderKeys = make([]ResponseHeaderKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResponseHeaderKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HeaderKeys = append(s.HeaderKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headerKeys\"")
			}
		case "jsonKeys":
			if err := func() error {
				s.JsonKeys = make([]JSONKey, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem JSONKey
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.JsonKeys = append(s.JsonKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jsonKeys\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseRemoveDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseRemoveDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseRemoveDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseRenameDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseRenameDetail) encodeFields(e *jx.Encoder) {
	{
		if s.IfStatusCode != nil {
			e.FieldStart("ifStatusCode")
			e.ArrStart()
			for _, elem := range s.IfStatusCode {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Headers != nil {
			e.FieldStart("headers")
			e.ArrStart()
			for _, elem := range s.Headers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.JSON != nil {
			e.FieldStart("json")
			e.ArrStart()
			for _, elem := range s.JSON {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfResponseRenameDetail = [3]string{
	0: "ifStatusCode",
	1: "headers",
	2: "json",
}

// Decode decodes ResponseRenameDetail from json.
func (s *ResponseRenameDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseRenameDetail to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ifStatusCode":
			if err := func() error {
				s.IfStatusCode = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.IfStatusCode = append(s.IfStatusCode, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ifStatusCode\"")
			}
		case "headers":
			if err := func() error {
				s.Headers = make([]ResponseRenameDetailHeadersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResponseRenameDetailHeadersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Headers = append(s.Headers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "json":
			if err := func() error {
				s.JSON = make([]ResponseRenameDetailJSONItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResponseRenameDetailJSONItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.JSON = append(s.JSON, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"json\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseRenameDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseRenameDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseRenameDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseRenameDetailHeadersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseRenameDetailHeadersItem) encodeFields(e *jx.Encoder) {
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e)
		}
	}
}

var jsonFieldsNameOfResponseRenameDetailHeadersItem = [2]string{
	0: "from",
	1: "to",
}

// Decode decodes ResponseRenameDetailHeadersItem from json.
func (s *ResponseRenameDetailHeadersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseRenameDetailHeadersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseRenameDetailHeadersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseRenameDetailHeadersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseRenameDetailHeadersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseRenameDetailJSONItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseRenameDetailJSONItem) encodeFields(e *jx.Encoder) {
	{
		if s.From.Set {
			e.FieldStart("from")
			s.From.Encode(e)
		}
	}
	{
		if s.To.Set {
			e.FieldStart("to")
			s.To.Encode(e)
		}
	}
}

var jsonFieldsNameOfResponseRenameDetailJSONItem = [2]string{
	0: "from",
	1: "to",
}

// Decode decodes ResponseRenameDetailJSONItem from json.
func (s *ResponseRenameDetailJSONItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseRenameDetailJSONItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "from":
			if err := func() error {
				s.From.Reset()
				if err := s.From.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"from\"")
			}
		case "to":
			if err := func() error {
				s.To.Reset()
				if err := s.To.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"to\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseRenameDetailJSONItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseRenameDetailJSONItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseRenameDetailJSONItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseReplaceDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseReplaceDetail) encodeFields(e *jx.Encoder) {
	{
		if s.IfStatusCode != nil {
			e.FieldStart("ifStatusCode")
			e.ArrStart()
			for _, elem := range s.IfStatusCode {
				e.Int(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Headers != nil {
			e.FieldStart("headers")
			e.ArrStart()
			for _, elem := range s.Headers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.JSON != nil {
			e.FieldStart("json")
			e.ArrStart()
			for _, elem := range s.JSON {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
}

var jsonFieldsNameOfResponseReplaceDetail = [4]string{
	0: "ifStatusCode",
	1: "headers",
	2: "json",
	3: "body",
}

// Decode decodes ResponseReplaceDetail from json.
func (s *ResponseReplaceDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseReplaceDetail to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ifStatusCode":
			if err := func() error {
				s.IfStatusCode = make([]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int
					v, err := d.Int()
					elem = int(v)
					if err != nil {
						return err
					}
					s.IfStatusCode = append(s.IfStatusCode, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ifStatusCode\"")
			}
		case "headers":
			if err := func() error {
				s.Headers = make([]ResponseReplaceDetailHeadersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResponseReplaceDetailHeadersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Headers = append(s.Headers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "json":
			if err := func() error {
				s.JSON = make([]ResponseReplaceDetailJSONItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResponseReplaceDetailJSONItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.JSON = append(s.JSON, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"json\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseReplaceDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseReplaceDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseReplaceDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseReplaceDetailHeadersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseReplaceDetailHeadersItem) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfResponseReplaceDetailHeadersItem = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes ResponseReplaceDetailHeadersItem from json.
func (s *ResponseReplaceDetailHeadersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseReplaceDetailHeadersItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseReplaceDetailHeadersItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseReplaceDetailHeadersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseReplaceDetailHeadersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseReplaceDetailJSONItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseReplaceDetailJSONItem) encodeFields(e *jx.Encoder) {
	{
		if s.Key.Set {
			e.FieldStart("key")
			s.Key.Encode(e)
		}
	}
	{
		if s.Value.Set {
			e.FieldStart("value")
			s.Value.Encode(e)
		}
	}
}

var jsonFieldsNameOfResponseReplaceDetailJSONItem = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes ResponseReplaceDetailJSONItem from json.
func (s *ResponseReplaceDetailJSONItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseReplaceDetailJSONItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			if err := func() error {
				s.Key.Reset()
				if err := s.Key.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			if err := func() error {
				s.Value.Reset()
				if err := s.Value.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseReplaceDetailJSONItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseReplaceDetailJSONItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseReplaceDetailJSONItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResponseTransformation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResponseTransformation) encodeFields(e *jx.Encoder) {
	{
		if s.Allow.Set {
			e.FieldStart("allow")
			s.Allow.Encode(e)
		}
	}
	{
		if s.Remove.Set {
			e.FieldStart("remove")
			s.Remove.Encode(e)
		}
	}
	{
		if s.Rename.Set {
			e.FieldStart("rename")
			s.Rename.Encode(e)
		}
	}
	{
		if s.Replace.Set {
			e.FieldStart("replace")
			s.Replace.Encode(e)
		}
	}
	{
		if s.Add.Set {
			e.FieldStart("add")
			s.Add.Encode(e)
		}
	}
	{
		if s.Append.Set {
			e.FieldStart("append")
			s.Append.Encode(e)
		}
	}
}

var jsonFieldsNameOfResponseTransformation = [6]string{
	0: "allow",
	1: "remove",
	2: "rename",
	3: "replace",
	4: "add",
	5: "append",
}

// Decode decodes ResponseTransformation from json.
func (s *ResponseTransformation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResponseTransformation to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "allow":
			if err := func() error {
				s.Allow.Reset()
				if err := s.Allow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allow\"")
			}
		case "remove":
			if err := func() error {
				s.Remove.Reset()
				if err := s.Remove.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove\"")
			}
		case "rename":
			if err := func() error {
				s.Rename.Reset()
				if err := s.Rename.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rename\"")
			}
		case "replace":
			if err := func() error {
				s.Replace.Reset()
				if err := s.Replace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replace\"")
			}
		case "add":
			if err := func() error {
				s.Add.Reset()
				if err := s.Add.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add\"")
			}
		case "append":
			if err := func() error {
				s.Append.Reset()
				if err := s.Append.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"append\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResponseTransformation")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResponseTransformation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResponseTransformation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Route) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Route) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ServiceId.Set {
			e.FieldStart("serviceId")
			s.ServiceId.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.Protocols.Set {
			e.FieldStart("protocols")
			s.Protocols.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Hosts != nil {
			e.FieldStart("hosts")
			e.ArrStart()
			for _, elem := range s.Hosts {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Methods != nil {
			e.FieldStart("methods")
			e.ArrStart()
			for _, elem := range s.Methods {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HttpsRedirectStatusCode.Set {
			e.FieldStart("httpsRedirectStatusCode")
			s.HttpsRedirectStatusCode.Encode(e)
		}
	}
	{
		if s.RegexPriority.Set {
			e.FieldStart("regexPriority")
			s.RegexPriority.Encode(e)
		}
	}
	{
		if s.StripPath.Set {
			e.FieldStart("stripPath")
			s.StripPath.Encode(e)
		}
	}
	{
		if s.PreserveHost.Set {
			e.FieldStart("preserveHost")
			s.PreserveHost.Encode(e)
		}
	}
	{
		if s.RequestBuffering.Set {
			e.FieldStart("requestBuffering")
			s.RequestBuffering.Encode(e)
		}
	}
	{
		if s.ResponseBuffering.Set {
			e.FieldStart("responseBuffering")
			s.ResponseBuffering.Encode(e)
		}
	}
}

var jsonFieldsNameOfRoute = [17]string{
	0:  "id",
	1:  "createdAt",
	2:  "updatedAt",
	3:  "serviceId",
	4:  "name",
	5:  "tags",
	6:  "protocols",
	7:  "path",
	8:  "host",
	9:  "hosts",
	10: "methods",
	11: "httpsRedirectStatusCode",
	12: "regexPriority",
	13: "stripPath",
	14: "preserveHost",
	15: "requestBuffering",
	16: "responseBuffering",
}

// Decode decodes Route from json.
func (s *Route) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Route to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "serviceId":
			if err := func() error {
				s.ServiceId.Reset()
				if err := s.ServiceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceId\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "tags":
			if err := func() error {
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "protocols":
			if err := func() error {
				s.Protocols.Reset()
				if err := s.Protocols.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocols\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "hosts":
			if err := func() error {
				s.Hosts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hosts = append(s.Hosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hosts\"")
			}
		case "methods":
			if err := func() error {
				s.Methods = make([]HTTPMethod, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HTTPMethod
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Methods = append(s.Methods, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"methods\"")
			}
		case "httpsRedirectStatusCode":
			if err := func() error {
				s.HttpsRedirectStatusCode.Reset()
				if err := s.HttpsRedirectStatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpsRedirectStatusCode\"")
			}
		case "regexPriority":
			if err := func() error {
				s.RegexPriority.Reset()
				if err := s.RegexPriority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regexPriority\"")
			}
		case "stripPath":
			if err := func() error {
				s.StripPath.Reset()
				if err := s.StripPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stripPath\"")
			}
		case "preserveHost":
			if err := func() error {
				s.PreserveHost.Reset()
				if err := s.PreserveHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preserveHost\"")
			}
		case "requestBuffering":
			if err := func() error {
				s.RequestBuffering.Reset()
				if err := s.RequestBuffering.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestBuffering\"")
			}
		case "responseBuffering":
			if err := func() error {
				s.ResponseBuffering.Reset()
				if err := s.ResponseBuffering.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseBuffering\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Route")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Route) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Route) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RouteAuthorization) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RouteAuthorization) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
}

var jsonFieldsNameOfRouteAuthorization = [3]string{
	0: "id",
	1: "name",
	2: "enabled",
}

// Decode decodes RouteAuthorization from json.
func (s *RouteAuthorization) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RouteAuthorization to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RouteAuthorization")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RouteAuthorization) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RouteAuthorization) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RouteAuthorizationDetail as json.
func (s RouteAuthorizationDetail) Encode(e *jx.Encoder) {
	switch s.Type {
	case RouteAuthorizationDetail0RouteAuthorizationDetail:
		s.RouteAuthorizationDetail0.Encode(e)
	case RouteAuthorizationDetail1RouteAuthorizationDetail:
		s.RouteAuthorizationDetail1.Encode(e)
	}
}

func (s RouteAuthorizationDetail) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case RouteAuthorizationDetail0RouteAuthorizationDetail:
		s.RouteAuthorizationDetail0.encodeFields(e)
	case RouteAuthorizationDetail1RouteAuthorizationDetail:
		s.RouteAuthorizationDetail1.encodeFields(e)
	}
}

// Decode decodes RouteAuthorizationDetail from json.
func (s *RouteAuthorizationDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RouteAuthorizationDetail to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "groups":
				match := RouteAuthorizationDetail1RouteAuthorizationDetail
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		s.Type = RouteAuthorizationDetail0RouteAuthorizationDetail
	}
	switch s.Type {
	case RouteAuthorizationDetail0RouteAuthorizationDetail:
		if err := s.RouteAuthorizationDetail0.Decode(d); err != nil {
			return err
		}
	case RouteAuthorizationDetail1RouteAuthorizationDetail:
		if err := s.RouteAuthorizationDetail1.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RouteAuthorizationDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RouteAuthorizationDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RouteAuthorizationDetail0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RouteAuthorizationDetail0) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isACLEnabled")
		s.IsACLEnabled.Encode(e)
	}
}

var jsonFieldsNameOfRouteAuthorizationDetail0 = [1]string{
	0: "isACLEnabled",
}

// Decode decodes RouteAuthorizationDetail0 from json.
func (s *RouteAuthorizationDetail0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RouteAuthorizationDetail0 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isACLEnabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.IsACLEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isACLEnabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RouteAuthorizationDetail0")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRouteAuthorizationDetail0) {
					name = jsonFieldsNameOfRouteAuthorizationDetail0[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RouteAuthorizationDetail0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RouteAuthorizationDetail0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RouteAuthorizationDetail0IsACLEnabled as json.
func (s RouteAuthorizationDetail0IsACLEnabled) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes RouteAuthorizationDetail0IsACLEnabled from json.
func (s *RouteAuthorizationDetail0IsACLEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RouteAuthorizationDetail0IsACLEnabled to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = RouteAuthorizationDetail0IsACLEnabled(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RouteAuthorizationDetail0IsACLEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RouteAuthorizationDetail0IsACLEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RouteAuthorizationDetail1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RouteAuthorizationDetail1) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isACLEnabled")
		s.IsACLEnabled.Encode(e)
	}
	{
		e.FieldStart("groups")
		e.ArrStart()
		for _, elem := range s.Groups {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRouteAuthorizationDetail1 = [2]string{
	0: "isACLEnabled",
	1: "groups",
}

// Decode decodes RouteAuthorizationDetail1 from json.
func (s *RouteAuthorizationDetail1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RouteAuthorizationDetail1 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isACLEnabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.IsACLEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isACLEnabled\"")
			}
		case "groups":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Groups = make([]RouteAuthorization, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RouteAuthorization
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RouteAuthorizationDetail1")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRouteAuthorizationDetail1) {
					name = jsonFieldsNameOfRouteAuthorizationDetail1[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RouteAuthorizationDetail1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RouteAuthorizationDetail1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RouteAuthorizationDetail1IsACLEnabled as json.
func (s RouteAuthorizationDetail1IsACLEnabled) Encode(e *jx.Encoder) {
	e.Bool(bool(s))
}

// Decode decodes RouteAuthorizationDetail1IsACLEnabled from json.
func (s *RouteAuthorizationDetail1IsACLEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RouteAuthorizationDetail1IsACLEnabled to nil")
	}
	v, err := d.Bool()
	if err != nil {
		return err
	}
	*s = RouteAuthorizationDetail1IsACLEnabled(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RouteAuthorizationDetail1IsACLEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RouteAuthorizationDetail1IsACLEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RouteAuthorizationDetailResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RouteAuthorizationDetailResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isACLEnabled")
		e.Bool(s.IsACLEnabled)
	}
	{
		e.FieldStart("groups")
		e.ArrStart()
		for _, elem := range s.Groups {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfRouteAuthorizationDetailResponse = [2]string{
	0: "isACLEnabled",
	1: "groups",
}

// Decode decodes RouteAuthorizationDetailResponse from json.
func (s *RouteAuthorizationDetailResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RouteAuthorizationDetailResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isACLEnabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsACLEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isACLEnabled\"")
			}
		case "groups":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Groups = make([]RouteAuthorization, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RouteAuthorization
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RouteAuthorizationDetailResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRouteAuthorizationDetailResponse) {
					name = jsonFieldsNameOfRouteAuthorizationDetailResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RouteAuthorizationDetailResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RouteAuthorizationDetailResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RouteDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RouteDetail) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.ServiceId.Set {
			e.FieldStart("serviceId")
			s.ServiceId.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.Protocols.Set {
			e.FieldStart("protocols")
			s.Protocols.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Hosts != nil {
			e.FieldStart("hosts")
			e.ArrStart()
			for _, elem := range s.Hosts {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Methods != nil {
			e.FieldStart("methods")
			e.ArrStart()
			for _, elem := range s.Methods {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.HttpsRedirectStatusCode.Set {
			e.FieldStart("httpsRedirectStatusCode")
			s.HttpsRedirectStatusCode.Encode(e)
		}
	}
	{
		if s.RegexPriority.Set {
			e.FieldStart("regexPriority")
			s.RegexPriority.Encode(e)
		}
	}
	{
		if s.StripPath.Set {
			e.FieldStart("stripPath")
			s.StripPath.Encode(e)
		}
	}
	{
		if s.PreserveHost.Set {
			e.FieldStart("preserveHost")
			s.PreserveHost.Encode(e)
		}
	}
	{
		if s.RequestBuffering.Set {
			e.FieldStart("requestBuffering")
			s.RequestBuffering.Encode(e)
		}
	}
	{
		if s.ResponseBuffering.Set {
			e.FieldStart("responseBuffering")
			s.ResponseBuffering.Encode(e)
		}
	}
	{
		if s.IpRestrictionConfig.Set {
			e.FieldStart("ipRestrictionConfig")
			s.IpRestrictionConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfRouteDetail = [18]string{
	0:  "id",
	1:  "createdAt",
	2:  "updatedAt",
	3:  "serviceId",
	4:  "name",
	5:  "tags",
	6:  "protocols",
	7:  "path",
	8:  "host",
	9:  "hosts",
	10: "methods",
	11: "httpsRedirectStatusCode",
	12: "regexPriority",
	13: "stripPath",
	14: "preserveHost",
	15: "requestBuffering",
	16: "responseBuffering",
	17: "ipRestrictionConfig",
}

// Decode decodes RouteDetail from json.
func (s *RouteDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RouteDetail to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "serviceId":
			if err := func() error {
				s.ServiceId.Reset()
				if err := s.ServiceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serviceId\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "tags":
			if err := func() error {
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "protocols":
			if err := func() error {
				s.Protocols.Reset()
				if err := s.Protocols.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocols\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "hosts":
			if err := func() error {
				s.Hosts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hosts = append(s.Hosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hosts\"")
			}
		case "methods":
			if err := func() error {
				s.Methods = make([]HTTPMethod, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HTTPMethod
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Methods = append(s.Methods, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"methods\"")
			}
		case "httpsRedirectStatusCode":
			if err := func() error {
				s.HttpsRedirectStatusCode.Reset()
				if err := s.HttpsRedirectStatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"httpsRedirectStatusCode\"")
			}
		case "regexPriority":
			if err := func() error {
				s.RegexPriority.Reset()
				if err := s.RegexPriority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regexPriority\"")
			}
		case "stripPath":
			if err := func() error {
				s.StripPath.Reset()
				if err := s.StripPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stripPath\"")
			}
		case "preserveHost":
			if err := func() error {
				s.PreserveHost.Reset()
				if err := s.PreserveHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"preserveHost\"")
			}
		case "requestBuffering":
			if err := func() error {
				s.RequestBuffering.Reset()
				if err := s.RequestBuffering.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestBuffering\"")
			}
		case "responseBuffering":
			if err := func() error {
				s.ResponseBuffering.Reset()
				if err := s.ResponseBuffering.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseBuffering\"")
			}
		case "ipRestrictionConfig":
			if err := func() error {
				s.IpRestrictionConfig.Reset()
				if err := s.IpRestrictionConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipRestrictionConfig\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RouteDetail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RouteDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RouteDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RouteDetailHttpsRedirectStatusCode as json.
func (s RouteDetailHttpsRedirectStatusCode) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes RouteDetailHttpsRedirectStatusCode from json.
func (s *RouteDetailHttpsRedirectStatusCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RouteDetailHttpsRedirectStatusCode to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = RouteDetailHttpsRedirectStatusCode(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RouteDetailHttpsRedirectStatusCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RouteDetailHttpsRedirectStatusCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RouteDetailProtocols as json.
func (s RouteDetailProtocols) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RouteDetailProtocols from json.
func (s *RouteDetailProtocols) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RouteDetailProtocols to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RouteDetailProtocols(v) {
	case RouteDetailProtocolsHTTPHTTPS:
		*s = RouteDetailProtocolsHTTPHTTPS
	case RouteDetailProtocolsHTTP:
		*s = RouteDetailProtocolsHTTP
	case RouteDetailProtocolsHTTPS:
		*s = RouteDetailProtocolsHTTPS
	default:
		*s = RouteDetailProtocols(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RouteDetailProtocols) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RouteDetailProtocols) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RouteHttpsRedirectStatusCode as json.
func (s RouteHttpsRedirectStatusCode) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes RouteHttpsRedirectStatusCode from json.
func (s *RouteHttpsRedirectStatusCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RouteHttpsRedirectStatusCode to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = RouteHttpsRedirectStatusCode(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RouteHttpsRedirectStatusCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RouteHttpsRedirectStatusCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RouteProtocols as json.
func (s RouteProtocols) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RouteProtocols from json.
func (s *RouteProtocols) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RouteProtocols to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RouteProtocols(v) {
	case RouteProtocolsHTTPHTTPS:
		*s = RouteProtocolsHTTPHTTPS
	case RouteProtocolsHTTP:
		*s = RouteProtocolsHTTP
	case RouteProtocolsHTTPS:
		*s = RouteProtocolsHTTPS
	default:
		*s = RouteProtocols(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RouteProtocols) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RouteProtocols) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceDetail) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		e.FieldStart("protocol")
		s.Protocol.Encode(e)
	}
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Retries.Set {
			e.FieldStart("retries")
			s.Retries.Encode(e)
		}
	}
	{
		if s.ConnectTimeout.Set {
			e.FieldStart("connectTimeout")
			s.ConnectTimeout.Encode(e)
		}
	}
	{
		if s.WriteTimeout.Set {
			e.FieldStart("writeTimeout")
			s.WriteTimeout.Encode(e)
		}
	}
	{
		if s.ReadTimeout.Set {
			e.FieldStart("readTimeout")
			s.ReadTimeout.Encode(e)
		}
	}
	{
		if s.Authentication.Set {
			e.FieldStart("authentication")
			s.Authentication.Encode(e)
		}
	}
	{
		if s.Oidc.Set {
			e.FieldStart("oidc")
			s.Oidc.Encode(e)
		}
	}
	{
		if s.RouteHost.Set {
			e.FieldStart("routeHost")
			s.RouteHost.Encode(e)
		}
	}
	{
		if s.CorsConfig.Set {
			e.FieldStart("corsConfig")
			s.CorsConfig.Encode(e)
		}
	}
	{
		if s.ObjectStorageConfig.Set {
			e.FieldStart("objectStorageConfig")
			s.ObjectStorageConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfServiceDetail = [18]string{
	0:  "id",
	1:  "createdAt",
	2:  "updatedAt",
	3:  "name",
	4:  "tags",
	5:  "protocol",
	6:  "host",
	7:  "path",
	8:  "port",
	9:  "retries",
	10: "connectTimeout",
	11: "writeTimeout",
	12: "readTimeout",
	13: "authentication",
	14: "oidc",
	15: "routeHost",
	16: "corsConfig",
	17: "objectStorageConfig",
}

// Decode decodes ServiceDetail from json.
func (s *ServiceDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceDetail to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "tags":
			if err := func() error {
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "protocol":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "retries":
			if err := func() error {
				s.Retries.Reset()
				if err := s.Retries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retries\"")
			}
		case "connectTimeout":
			if err := func() error {
				s.ConnectTimeout.Reset()
				if err := s.ConnectTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectTimeout\"")
			}
		case "writeTimeout":
			if err := func() error {
				s.WriteTimeout.Reset()
				if err := s.WriteTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"writeTimeout\"")
			}
		case "readTimeout":
			if err := func() error {
				s.ReadTimeout.Reset()
				if err := s.ReadTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readTimeout\"")
			}
		case "authentication":
			if err := func() error {
				s.Authentication.Reset()
				if err := s.Authentication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authentication\"")
			}
		case "oidc":
			if err := func() error {
				s.Oidc.Reset()
				if err := s.Oidc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidc\"")
			}
		case "routeHost":
			if err := func() error {
				s.RouteHost.Reset()
				if err := s.RouteHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"routeHost\"")
			}
		case "corsConfig":
			if err := func() error {
				s.CorsConfig.Reset()
				if err := s.CorsConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corsConfig\"")
			}
		case "objectStorageConfig":
			if err := func() error {
				s.ObjectStorageConfig.Reset()
				if err := s.ObjectStorageConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectStorageConfig\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceDetail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01101000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServiceDetail) {
					name = jsonFieldsNameOfServiceDetail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceDetailAuthentication as json.
func (s ServiceDetailAuthentication) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ServiceDetailAuthentication from json.
func (s *ServiceDetailAuthentication) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceDetailAuthentication to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ServiceDetailAuthentication(v) {
	case ServiceDetailAuthenticationNone:
		*s = ServiceDetailAuthenticationNone
	case ServiceDetailAuthenticationBasic:
		*s = ServiceDetailAuthenticationBasic
	case ServiceDetailAuthenticationHmac:
		*s = ServiceDetailAuthenticationHmac
	case ServiceDetailAuthenticationJwt:
		*s = ServiceDetailAuthenticationJwt
	case ServiceDetailAuthenticationOidc:
		*s = ServiceDetailAuthenticationOidc
	default:
		*s = ServiceDetailAuthentication(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServiceDetailAuthentication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceDetailAuthentication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceDetailProtocol as json.
func (s ServiceDetailProtocol) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ServiceDetailProtocol from json.
func (s *ServiceDetailProtocol) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceDetailProtocol to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ServiceDetailProtocol(v) {
	case ServiceDetailProtocolHTTP:
		*s = ServiceDetailProtocolHTTP
	case ServiceDetailProtocolHTTPS:
		*s = ServiceDetailProtocolHTTPS
	default:
		*s = ServiceDetailProtocol(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServiceDetailProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceDetailProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceDetailRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceDetailRequest) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		e.FieldStart("protocol")
		s.Protocol.Encode(e)
	}
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Retries.Set {
			e.FieldStart("retries")
			s.Retries.Encode(e)
		}
	}
	{
		if s.ConnectTimeout.Set {
			e.FieldStart("connectTimeout")
			s.ConnectTimeout.Encode(e)
		}
	}
	{
		if s.WriteTimeout.Set {
			e.FieldStart("writeTimeout")
			s.WriteTimeout.Encode(e)
		}
	}
	{
		if s.ReadTimeout.Set {
			e.FieldStart("readTimeout")
			s.ReadTimeout.Encode(e)
		}
	}
	{
		if s.Authentication.Set {
			e.FieldStart("authentication")
			s.Authentication.Encode(e)
		}
	}
	{
		if s.Oidc.Set {
			e.FieldStart("oidc")
			s.Oidc.Encode(e)
		}
	}
	{
		if s.RouteHost.Set {
			e.FieldStart("routeHost")
			s.RouteHost.Encode(e)
		}
	}
	{
		if s.CorsConfig.Set {
			e.FieldStart("corsConfig")
			s.CorsConfig.Encode(e)
		}
	}
	{
		if s.ObjectStorageConfig.Set {
			e.FieldStart("objectStorageConfig")
			s.ObjectStorageConfig.Encode(e)
		}
	}
	{
		e.FieldStart("subscription")
		s.Subscription.Encode(e)
	}
}

var jsonFieldsNameOfServiceDetailRequest = [19]string{
	0:  "id",
	1:  "createdAt",
	2:  "updatedAt",
	3:  "name",
	4:  "tags",
	5:  "protocol",
	6:  "host",
	7:  "path",
	8:  "port",
	9:  "retries",
	10: "connectTimeout",
	11: "writeTimeout",
	12: "readTimeout",
	13: "authentication",
	14: "oidc",
	15: "routeHost",
	16: "corsConfig",
	17: "objectStorageConfig",
	18: "subscription",
}

// Decode decodes ServiceDetailRequest from json.
func (s *ServiceDetailRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceDetailRequest to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "tags":
			if err := func() error {
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "protocol":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "retries":
			if err := func() error {
				s.Retries.Reset()
				if err := s.Retries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retries\"")
			}
		case "connectTimeout":
			if err := func() error {
				s.ConnectTimeout.Reset()
				if err := s.ConnectTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectTimeout\"")
			}
		case "writeTimeout":
			if err := func() error {
				s.WriteTimeout.Reset()
				if err := s.WriteTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"writeTimeout\"")
			}
		case "readTimeout":
			if err := func() error {
				s.ReadTimeout.Reset()
				if err := s.ReadTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readTimeout\"")
			}
		case "authentication":
			if err := func() error {
				s.Authentication.Reset()
				if err := s.Authentication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authentication\"")
			}
		case "oidc":
			if err := func() error {
				s.Oidc.Reset()
				if err := s.Oidc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidc\"")
			}
		case "routeHost":
			if err := func() error {
				s.RouteHost.Reset()
				if err := s.RouteHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"routeHost\"")
			}
		case "corsConfig":
			if err := func() error {
				s.CorsConfig.Reset()
				if err := s.CorsConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corsConfig\"")
			}
		case "objectStorageConfig":
			if err := func() error {
				s.ObjectStorageConfig.Reset()
				if err := s.ObjectStorageConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectStorageConfig\"")
			}
		case "subscription":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Subscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceDetailRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01101000,
		0b00000000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServiceDetailRequest) {
					name = jsonFieldsNameOfServiceDetailRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceDetailRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceDetailRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceDetailRequestAuthentication as json.
func (s ServiceDetailRequestAuthentication) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ServiceDetailRequestAuthentication from json.
func (s *ServiceDetailRequestAuthentication) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceDetailRequestAuthentication to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ServiceDetailRequestAuthentication(v) {
	case ServiceDetailRequestAuthenticationNone:
		*s = ServiceDetailRequestAuthenticationNone
	case ServiceDetailRequestAuthenticationBasic:
		*s = ServiceDetailRequestAuthenticationBasic
	case ServiceDetailRequestAuthenticationHmac:
		*s = ServiceDetailRequestAuthenticationHmac
	case ServiceDetailRequestAuthenticationJwt:
		*s = ServiceDetailRequestAuthenticationJwt
	case ServiceDetailRequestAuthenticationOidc:
		*s = ServiceDetailRequestAuthenticationOidc
	default:
		*s = ServiceDetailRequestAuthentication(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServiceDetailRequestAuthentication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceDetailRequestAuthentication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceDetailRequestProtocol as json.
func (s ServiceDetailRequestProtocol) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ServiceDetailRequestProtocol from json.
func (s *ServiceDetailRequestProtocol) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceDetailRequestProtocol to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ServiceDetailRequestProtocol(v) {
	case ServiceDetailRequestProtocolHTTP:
		*s = ServiceDetailRequestProtocolHTTP
	case ServiceDetailRequestProtocolHTTPS:
		*s = ServiceDetailRequestProtocolHTTPS
	default:
		*s = ServiceDetailRequestProtocol(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServiceDetailRequestProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceDetailRequestProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceDetailResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceDetailResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		e.FieldStart("protocol")
		s.Protocol.Encode(e)
	}
	{
		e.FieldStart("host")
		e.Str(s.Host)
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Retries.Set {
			e.FieldStart("retries")
			s.Retries.Encode(e)
		}
	}
	{
		if s.ConnectTimeout.Set {
			e.FieldStart("connectTimeout")
			s.ConnectTimeout.Encode(e)
		}
	}
	{
		if s.WriteTimeout.Set {
			e.FieldStart("writeTimeout")
			s.WriteTimeout.Encode(e)
		}
	}
	{
		if s.ReadTimeout.Set {
			e.FieldStart("readTimeout")
			s.ReadTimeout.Encode(e)
		}
	}
	{
		if s.Authentication.Set {
			e.FieldStart("authentication")
			s.Authentication.Encode(e)
		}
	}
	{
		if s.Oidc.Set {
			e.FieldStart("oidc")
			s.Oidc.Encode(e)
		}
	}
	{
		if s.RouteHost.Set {
			e.FieldStart("routeHost")
			s.RouteHost.Encode(e)
		}
	}
	{
		if s.CorsConfig.Set {
			e.FieldStart("corsConfig")
			s.CorsConfig.Encode(e)
		}
	}
	{
		if s.ObjectStorageConfig.Set {
			e.FieldStart("objectStorageConfig")
			s.ObjectStorageConfig.Encode(e)
		}
	}
	{
		e.FieldStart("subscription")
		s.Subscription.Encode(e)
	}
}

var jsonFieldsNameOfServiceDetailResponse = [19]string{
	0:  "id",
	1:  "createdAt",
	2:  "updatedAt",
	3:  "name",
	4:  "tags",
	5:  "protocol",
	6:  "host",
	7:  "path",
	8:  "port",
	9:  "retries",
	10: "connectTimeout",
	11: "writeTimeout",
	12: "readTimeout",
	13: "authentication",
	14: "oidc",
	15: "routeHost",
	16: "corsConfig",
	17: "objectStorageConfig",
	18: "subscription",
}

// Decode decodes ServiceDetailResponse from json.
func (s *ServiceDetailResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceDetailResponse to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "tags":
			if err := func() error {
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "protocol":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Host = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "retries":
			if err := func() error {
				s.Retries.Reset()
				if err := s.Retries.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"retries\"")
			}
		case "connectTimeout":
			if err := func() error {
				s.ConnectTimeout.Reset()
				if err := s.ConnectTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectTimeout\"")
			}
		case "writeTimeout":
			if err := func() error {
				s.WriteTimeout.Reset()
				if err := s.WriteTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"writeTimeout\"")
			}
		case "readTimeout":
			if err := func() error {
				s.ReadTimeout.Reset()
				if err := s.ReadTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readTimeout\"")
			}
		case "authentication":
			if err := func() error {
				s.Authentication.Reset()
				if err := s.Authentication.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authentication\"")
			}
		case "oidc":
			if err := func() error {
				s.Oidc.Reset()
				if err := s.Oidc.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oidc\"")
			}
		case "routeHost":
			if err := func() error {
				s.RouteHost.Reset()
				if err := s.RouteHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"routeHost\"")
			}
		case "corsConfig":
			if err := func() error {
				s.CorsConfig.Reset()
				if err := s.CorsConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"corsConfig\"")
			}
		case "objectStorageConfig":
			if err := func() error {
				s.ObjectStorageConfig.Reset()
				if err := s.ObjectStorageConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"objectStorageConfig\"")
			}
		case "subscription":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Subscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceDetailResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b01101000,
		0b00000000,
		0b00000100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServiceDetailResponse) {
					name = jsonFieldsNameOfServiceDetailResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceDetailResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceDetailResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceDetailResponseAuthentication as json.
func (s ServiceDetailResponseAuthentication) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ServiceDetailResponseAuthentication from json.
func (s *ServiceDetailResponseAuthentication) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceDetailResponseAuthentication to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ServiceDetailResponseAuthentication(v) {
	case ServiceDetailResponseAuthenticationNone:
		*s = ServiceDetailResponseAuthenticationNone
	case ServiceDetailResponseAuthenticationBasic:
		*s = ServiceDetailResponseAuthenticationBasic
	case ServiceDetailResponseAuthenticationHmac:
		*s = ServiceDetailResponseAuthenticationHmac
	case ServiceDetailResponseAuthenticationJwt:
		*s = ServiceDetailResponseAuthenticationJwt
	case ServiceDetailResponseAuthenticationOidc:
		*s = ServiceDetailResponseAuthenticationOidc
	default:
		*s = ServiceDetailResponseAuthentication(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServiceDetailResponseAuthentication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceDetailResponseAuthentication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServiceDetailResponseProtocol as json.
func (s ServiceDetailResponseProtocol) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ServiceDetailResponseProtocol from json.
func (s *ServiceDetailResponseProtocol) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceDetailResponseProtocol to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ServiceDetailResponseProtocol(v) {
	case ServiceDetailResponseProtocolHTTP:
		*s = ServiceDetailResponseProtocolHTTP
	case ServiceDetailResponseProtocolHTTPS:
		*s = ServiceDetailResponseProtocolHTTPS
	default:
		*s = ServiceDetailResponseProtocol(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServiceDetailResponseProtocol) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceDetailResponseProtocol) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceSubscriptionRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceSubscriptionRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
}

var jsonFieldsNameOfServiceSubscriptionRequest = [1]string{
	0: "id",
}

// Decode decodes ServiceSubscriptionRequest from json.
func (s *ServiceSubscriptionRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceSubscriptionRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceSubscriptionRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServiceSubscriptionRequest) {
					name = jsonFieldsNameOfServiceSubscriptionRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceSubscriptionRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceSubscriptionRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceSubscriptionResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceSubscriptionResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfServiceSubscriptionResponse = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes ServiceSubscriptionResponse from json.
func (s *ServiceSubscriptionResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceSubscriptionResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceSubscriptionResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServiceSubscriptionResponse) {
					name = jsonFieldsNameOfServiceSubscriptionResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceSubscriptionResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceSubscriptionResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServiceSummary) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServiceSummary) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfServiceSummary = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes ServiceSummary from json.
func (s *ServiceSummary) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServiceSummary to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServiceSummary")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServiceSummary) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServiceSummary) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubscribeBadRequest as json.
func (s *SubscribeBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubscribeBadRequest from json.
func (s *SubscribeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscribeBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubscribeBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscribeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscribeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubscribeInternalServerError as json.
func (s *SubscribeInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubscribeInternalServerError from json.
func (s *SubscribeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscribeInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubscribeInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscribeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscribeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubscribeUnauthorized as json.
func (s *SubscribeUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes SubscribeUnauthorized from json.
func (s *SubscribeUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscribeUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = SubscribeUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscribeUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscribeUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Subscription) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Subscription) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.PlanId.Set {
			e.FieldStart("planId")
			s.PlanId.Encode(e)
		}
	}
	{
		if s.ResourceId.Set {
			e.FieldStart("resourceId")
			s.ResourceId.Encode(e)
		}
	}
	{
		if s.MonthlyRequest.Set {
			e.FieldStart("monthlyRequest")
			s.MonthlyRequest.Encode(e)
		}
	}
	{
		if s.Service.Set {
			e.FieldStart("service")
			s.Service.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscription = [8]string{
	0: "id",
	1: "createdAt",
	2: "updatedAt",
	3: "name",
	4: "planId",
	5: "resourceId",
	6: "monthlyRequest",
	7: "service",
}

// Decode decodes Subscription from json.
func (s *Subscription) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Subscription to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "planId":
			if err := func() error {
				s.PlanId.Reset()
				if err := s.PlanId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"planId\"")
			}
		case "resourceId":
			if err := func() error {
				s.ResourceId.Reset()
				if err := s.ResourceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "monthlyRequest":
			if err := func() error {
				s.MonthlyRequest.Reset()
				if err := s.MonthlyRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monthlyRequest\"")
			}
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Subscription")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Subscription) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Subscription) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionCreate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionCreate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("planId")
		json.EncodeUUID(e, s.PlanId)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfSubscriptionCreate = [2]string{
	0: "planId",
	1: "name",
}

// Decode decodes SubscriptionCreate from json.
func (s *SubscriptionCreate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionCreate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "planId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.PlanId = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"planId\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionCreate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubscriptionCreate) {
					name = jsonFieldsNameOfSubscriptionCreate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionCreate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionCreate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionDetailResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionDetailResponse) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.ResourceId.Set {
			e.FieldStart("resourceId")
			s.ResourceId.Encode(e)
		}
	}
	{
		if s.MonthlyRequest.Set {
			e.FieldStart("monthlyRequest")
			s.MonthlyRequest.Encode(e)
		}
	}
	{
		if s.Service.Set {
			e.FieldStart("service")
			s.Service.Encode(e)
		}
	}
	{
		if s.Plan.Set {
			e.FieldStart("plan")
			s.Plan.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionDetailResponse = [8]string{
	0: "id",
	1: "createdAt",
	2: "updatedAt",
	3: "name",
	4: "resourceId",
	5: "monthlyRequest",
	6: "service",
	7: "plan",
}

// Decode decodes SubscriptionDetailResponse from json.
func (s *SubscriptionDetailResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionDetailResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "resourceId":
			if err := func() error {
				s.ResourceId.Reset()
				if err := s.ResourceId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"resourceId\"")
			}
		case "monthlyRequest":
			if err := func() error {
				s.MonthlyRequest.Reset()
				if err := s.MonthlyRequest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monthlyRequest\"")
			}
		case "service":
			if err := func() error {
				s.Service.Reset()
				if err := s.Service.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"service\"")
			}
		case "plan":
			if err := func() error {
				s.Plan.Reset()
				if err := s.Plan.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plan\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionDetailResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionDetailResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionDetailResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionList) encodeFields(e *jx.Encoder) {
	{
		if s.Subscriptions != nil {
			e.FieldStart("subscriptions")
			e.ArrStart()
			for _, elem := range s.Subscriptions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.MaxSubscription.Set {
			e.FieldStart("maxSubscription")
			s.MaxSubscription.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionList = [2]string{
	0: "subscriptions",
	1: "maxSubscription",
}

// Decode decodes SubscriptionList from json.
func (s *SubscriptionList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscriptions":
			if err := func() error {
				s.Subscriptions = make([]Subscription, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Subscription
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subscriptions = append(s.Subscriptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions\"")
			}
		case "maxSubscription":
			if err := func() error {
				s.MaxSubscription.Reset()
				if err := s.MaxSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxSubscription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionPlanResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionPlanResponse) encodeFields(e *jx.Encoder) {
	{
		if s.PlanID.Set {
			e.FieldStart("planID")
			s.PlanID.Encode(e)
		}
	}
	{
		if s.PlanName.Set {
			e.FieldStart("planName")
			s.PlanName.Encode(e)
		}
	}
	{
		if s.Price.Set {
			e.FieldStart("price")
			s.Price.Encode(e)
		}
	}
	{
		if s.MaxServices.Set {
			e.FieldStart("maxServices")
			s.MaxServices.Encode(e)
		}
	}
	{
		if s.MaxRequests.Set {
			e.FieldStart("maxRequests")
			s.MaxRequests.Encode(e)
		}
	}
	{
		if s.MaxRequestsUnit.Set {
			e.FieldStart("maxRequestsUnit")
			s.MaxRequestsUnit.Encode(e)
		}
	}
	{
		if s.Overage.Set {
			e.FieldStart("overage")
			s.Overage.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionPlanResponse = [7]string{
	0: "planID",
	1: "planName",
	2: "price",
	3: "maxServices",
	4: "maxRequests",
	5: "maxRequestsUnit",
	6: "overage",
}

// Decode decodes SubscriptionPlanResponse from json.
func (s *SubscriptionPlanResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionPlanResponse to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "planID":
			if err := func() error {
				s.PlanID.Reset()
				if err := s.PlanID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"planID\"")
			}
		case "planName":
			if err := func() error {
				s.PlanName.Reset()
				if err := s.PlanName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"planName\"")
			}
		case "price":
			if err := func() error {
				s.Price.Reset()
				if err := s.Price.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"price\"")
			}
		case "maxServices":
			if err := func() error {
				s.MaxServices.Reset()
				if err := s.MaxServices.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxServices\"")
			}
		case "maxRequests":
			if err := func() error {
				s.MaxRequests.Reset()
				if err := s.MaxRequests.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxRequests\"")
			}
		case "maxRequestsUnit":
			if err := func() error {
				s.MaxRequestsUnit.Reset()
				if err := s.MaxRequestsUnit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxRequestsUnit\"")
			}
		case "overage":
			if err := func() error {
				s.Overage.Reset()
				if err := s.Overage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overage\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionPlanResponse")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionPlanResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionPlanResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SubscriptionPlanResponseMaxRequestsUnit as json.
func (s SubscriptionPlanResponseMaxRequestsUnit) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SubscriptionPlanResponseMaxRequestsUnit from json.
func (s *SubscriptionPlanResponseMaxRequestsUnit) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionPlanResponseMaxRequestsUnit to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SubscriptionPlanResponseMaxRequestsUnit(v) {
	case SubscriptionPlanResponseMaxRequestsUnitSecond:
		*s = SubscriptionPlanResponseMaxRequestsUnitSecond
	case SubscriptionPlanResponseMaxRequestsUnitMinute:
		*s = SubscriptionPlanResponseMaxRequestsUnitMinute
	case SubscriptionPlanResponseMaxRequestsUnitHour:
		*s = SubscriptionPlanResponseMaxRequestsUnitHour
	case SubscriptionPlanResponseMaxRequestsUnitDay:
		*s = SubscriptionPlanResponseMaxRequestsUnitDay
	case SubscriptionPlanResponseMaxRequestsUnitMonth:
		*s = SubscriptionPlanResponseMaxRequestsUnitMonth
	case SubscriptionPlanResponseMaxRequestsUnitYear:
		*s = SubscriptionPlanResponseMaxRequestsUnitYear
	default:
		*s = SubscriptionPlanResponseMaxRequestsUnit(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SubscriptionPlanResponseMaxRequestsUnit) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionPlanResponseMaxRequestsUnit) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionService) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionService) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfSubscriptionService = [2]string{
	0: "id",
	1: "name",
}

// Decode decodes SubscriptionService from json.
func (s *SubscriptionService) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionService to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionService")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubscriptionService) {
					name = jsonFieldsNameOfSubscriptionService[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionService) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionService) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionUpdate) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionUpdate) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfSubscriptionUpdate = [1]string{
	0: "name",
}

// Decode decodes SubscriptionUpdate from json.
func (s *SubscriptionUpdate) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionUpdate to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionUpdate")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSubscriptionUpdate) {
					name = jsonFieldsNameOfSubscriptionUpdate[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionUpdate) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionUpdate) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Tags as json.
func (s Tags) Encode(e *jx.Encoder) {
	unwrapped := []string(s)
	if unwrapped == nil {
		e.ArrEmpty()
		return
	}
	if unwrapped != nil {
		e.ArrStart()
		for _, elem := range unwrapped {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes Tags from json.
func (s *Tags) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Tags to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = Tags(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Tags) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Tags) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnsubscribeBadRequest as json.
func (s *UnsubscribeBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UnsubscribeBadRequest from json.
func (s *UnsubscribeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnsubscribeBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UnsubscribeBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnsubscribeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnsubscribeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnsubscribeInternalServerError as json.
func (s *UnsubscribeInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UnsubscribeInternalServerError from json.
func (s *UnsubscribeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnsubscribeInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UnsubscribeInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnsubscribeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnsubscribeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnsubscribeNotFound as json.
func (s *UnsubscribeNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UnsubscribeNotFound from json.
func (s *UnsubscribeNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnsubscribeNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UnsubscribeNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnsubscribeNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnsubscribeNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCertificateBadRequest as json.
func (s *UpdateCertificateBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateCertificateBadRequest from json.
func (s *UpdateCertificateBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCertificateBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateCertificateBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCertificateBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCertificateBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCertificateConflict as json.
func (s *UpdateCertificateConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateCertificateConflict from json.
func (s *UpdateCertificateConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCertificateConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateCertificateConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCertificateConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCertificateConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCertificateInternalServerError as json.
func (s *UpdateCertificateInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateCertificateInternalServerError from json.
func (s *UpdateCertificateInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCertificateInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateCertificateInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCertificateInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCertificateInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCertificateNotFound as json.
func (s *UpdateCertificateNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateCertificateNotFound from json.
func (s *UpdateCertificateNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCertificateNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateCertificateNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCertificateNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCertificateNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCertificateUnauthorized as json.
func (s *UpdateCertificateUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateCertificateUnauthorized from json.
func (s *UpdateCertificateUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCertificateUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateCertificateUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCertificateUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCertificateUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateCertificateUnprocessableEntity as json.
func (s *UpdateCertificateUnprocessableEntity) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateCertificateUnprocessableEntity from json.
func (s *UpdateCertificateUnprocessableEntity) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateCertificateUnprocessableEntity to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateCertificateUnprocessableEntity(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateCertificateUnprocessableEntity) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateCertificateUnprocessableEntity) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDomainBadRequest as json.
func (s *UpdateDomainBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDomainBadRequest from json.
func (s *UpdateDomainBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDomainBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDomainBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDomainBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDomainBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDomainConflict as json.
func (s *UpdateDomainConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDomainConflict from json.
func (s *UpdateDomainConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDomainConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDomainConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDomainConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDomainConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDomainInternalServerError as json.
func (s *UpdateDomainInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDomainInternalServerError from json.
func (s *UpdateDomainInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDomainInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDomainInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDomainInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDomainInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDomainNotFound as json.
func (s *UpdateDomainNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDomainNotFound from json.
func (s *UpdateDomainNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDomainNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDomainNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDomainNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDomainNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateDomainUnauthorized as json.
func (s *UpdateDomainUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateDomainUnauthorized from json.
func (s *UpdateDomainUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateDomainUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateDomainUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateDomainUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateDomainUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateGroupBadRequest as json.
func (s *UpdateGroupBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateGroupBadRequest from json.
func (s *UpdateGroupBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateGroupBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateGroupBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateGroupBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateGroupBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateGroupConflict as json.
func (s *UpdateGroupConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateGroupConflict from json.
func (s *UpdateGroupConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateGroupConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateGroupConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateGroupConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateGroupConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateGroupInternalServerError as json.
func (s *UpdateGroupInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateGroupInternalServerError from json.
func (s *UpdateGroupInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateGroupInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateGroupInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateGroupInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateGroupInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateGroupNotFound as json.
func (s *UpdateGroupNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateGroupNotFound from json.
func (s *UpdateGroupNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateGroupNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateGroupNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateGroupNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateGroupNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateGroupUnauthorized as json.
func (s *UpdateGroupUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateGroupUnauthorized from json.
func (s *UpdateGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateGroupUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateGroupUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateGroupUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateGroupUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateOidcBadRequest as json.
func (s *UpdateOidcBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateOidcBadRequest from json.
func (s *UpdateOidcBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateOidcBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateOidcBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateOidcBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateOidcBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateOidcConflict as json.
func (s *UpdateOidcConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateOidcConflict from json.
func (s *UpdateOidcConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateOidcConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateOidcConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateOidcConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateOidcConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateOidcInternalServerError as json.
func (s *UpdateOidcInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateOidcInternalServerError from json.
func (s *UpdateOidcInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateOidcInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateOidcInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateOidcInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateOidcInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateOidcNotFound as json.
func (s *UpdateOidcNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateOidcNotFound from json.
func (s *UpdateOidcNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateOidcNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateOidcNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateOidcNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateOidcNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateOidcUnauthorized as json.
func (s *UpdateOidcUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateOidcUnauthorized from json.
func (s *UpdateOidcUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateOidcUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateOidcUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateOidcUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateOidcUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRouteBadRequest as json.
func (s *UpdateRouteBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateRouteBadRequest from json.
func (s *UpdateRouteBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRouteBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateRouteBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRouteBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRouteBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRouteConflict as json.
func (s *UpdateRouteConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateRouteConflict from json.
func (s *UpdateRouteConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRouteConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateRouteConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRouteConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRouteConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRouteInternalServerError as json.
func (s *UpdateRouteInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateRouteInternalServerError from json.
func (s *UpdateRouteInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRouteInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateRouteInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRouteInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRouteInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRouteNotFound as json.
func (s *UpdateRouteNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateRouteNotFound from json.
func (s *UpdateRouteNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRouteNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateRouteNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRouteNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRouteNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRouteUnauthorized as json.
func (s *UpdateRouteUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateRouteUnauthorized from json.
func (s *UpdateRouteUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRouteUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateRouteUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRouteUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRouteUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateServiceBadRequest as json.
func (s *UpdateServiceBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateServiceBadRequest from json.
func (s *UpdateServiceBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateServiceBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateServiceBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateServiceBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateServiceBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateServiceConflict as json.
func (s *UpdateServiceConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateServiceConflict from json.
func (s *UpdateServiceConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateServiceConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateServiceConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateServiceConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateServiceConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateServiceInternalServerError as json.
func (s *UpdateServiceInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateServiceInternalServerError from json.
func (s *UpdateServiceInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateServiceInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateServiceInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateServiceInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateServiceInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateServiceNotFound as json.
func (s *UpdateServiceNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateServiceNotFound from json.
func (s *UpdateServiceNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateServiceNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateServiceNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateServiceNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateServiceNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateServiceUnauthorized as json.
func (s *UpdateServiceUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateServiceUnauthorized from json.
func (s *UpdateServiceUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateServiceUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateServiceUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateServiceUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateServiceUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionBadRequest as json.
func (s *UpdateSubscriptionBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateSubscriptionBadRequest from json.
func (s *UpdateSubscriptionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateSubscriptionBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionInternalServerError as json.
func (s *UpdateSubscriptionInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateSubscriptionInternalServerError from json.
func (s *UpdateSubscriptionInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateSubscriptionInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionUnauthorized as json.
func (s *UpdateSubscriptionUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateSubscriptionUnauthorized from json.
func (s *UpdateSubscriptionUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateSubscriptionUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserBadRequest as json.
func (s *UpdateUserBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUserBadRequest from json.
func (s *UpdateUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUserBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserConflict as json.
func (s *UpdateUserConflict) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUserConflict from json.
func (s *UpdateUserConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserConflict to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUserConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserGroupBadRequest as json.
func (s *UpdateUserGroupBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUserGroupBadRequest from json.
func (s *UpdateUserGroupBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserGroupBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUserGroupBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserGroupBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserGroupBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserGroupInternalServerError as json.
func (s *UpdateUserGroupInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUserGroupInternalServerError from json.
func (s *UpdateUserGroupInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserGroupInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUserGroupInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserGroupInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserGroupInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserGroupNotFound as json.
func (s *UpdateUserGroupNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUserGroupNotFound from json.
func (s *UpdateUserGroupNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserGroupNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUserGroupNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserGroupNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserGroupNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserGroupUnauthorized as json.
func (s *UpdateUserGroupUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUserGroupUnauthorized from json.
func (s *UpdateUserGroupUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserGroupUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUserGroupUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserGroupUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserGroupUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserInternalServerError as json.
func (s *UpdateUserInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUserInternalServerError from json.
func (s *UpdateUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUserInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserNotFound as json.
func (s *UpdateUserNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUserNotFound from json.
func (s *UpdateUserNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUserNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserUnauthorized as json.
func (s *UpdateUserUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpdateUserUnauthorized from json.
func (s *UpdateUserUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpdateUserUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertRequestTransformationBadRequest as json.
func (s *UpsertRequestTransformationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertRequestTransformationBadRequest from json.
func (s *UpsertRequestTransformationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertRequestTransformationBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertRequestTransformationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertRequestTransformationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertRequestTransformationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertRequestTransformationInternalServerError as json.
func (s *UpsertRequestTransformationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertRequestTransformationInternalServerError from json.
func (s *UpsertRequestTransformationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertRequestTransformationInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertRequestTransformationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertRequestTransformationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertRequestTransformationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertRequestTransformationNotFound as json.
func (s *UpsertRequestTransformationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertRequestTransformationNotFound from json.
func (s *UpsertRequestTransformationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertRequestTransformationNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertRequestTransformationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertRequestTransformationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertRequestTransformationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertResponseTransformationBadRequest as json.
func (s *UpsertResponseTransformationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertResponseTransformationBadRequest from json.
func (s *UpsertResponseTransformationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertResponseTransformationBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertResponseTransformationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertResponseTransformationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertResponseTransformationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertResponseTransformationInternalServerError as json.
func (s *UpsertResponseTransformationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertResponseTransformationInternalServerError from json.
func (s *UpsertResponseTransformationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertResponseTransformationInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertResponseTransformationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertResponseTransformationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertResponseTransformationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertResponseTransformationNotFound as json.
func (s *UpsertResponseTransformationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertResponseTransformationNotFound from json.
func (s *UpsertResponseTransformationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertResponseTransformationNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertResponseTransformationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertResponseTransformationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertResponseTransformationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertResponseTransformationUnauthorized as json.
func (s *UpsertResponseTransformationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertResponseTransformationUnauthorized from json.
func (s *UpsertResponseTransformationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertResponseTransformationUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertResponseTransformationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertResponseTransformationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertResponseTransformationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertRouteAuthorizationBadRequest as json.
func (s *UpsertRouteAuthorizationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertRouteAuthorizationBadRequest from json.
func (s *UpsertRouteAuthorizationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertRouteAuthorizationBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertRouteAuthorizationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertRouteAuthorizationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertRouteAuthorizationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertRouteAuthorizationInternalServerError as json.
func (s *UpsertRouteAuthorizationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertRouteAuthorizationInternalServerError from json.
func (s *UpsertRouteAuthorizationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertRouteAuthorizationInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertRouteAuthorizationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertRouteAuthorizationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertRouteAuthorizationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertRouteAuthorizationNotFound as json.
func (s *UpsertRouteAuthorizationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertRouteAuthorizationNotFound from json.
func (s *UpsertRouteAuthorizationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertRouteAuthorizationNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertRouteAuthorizationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertRouteAuthorizationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertRouteAuthorizationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertRouteAuthorizationUnauthorized as json.
func (s *UpsertRouteAuthorizationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertRouteAuthorizationUnauthorized from json.
func (s *UpsertRouteAuthorizationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertRouteAuthorizationUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertRouteAuthorizationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertRouteAuthorizationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertRouteAuthorizationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertUserAuthenticationBadRequest as json.
func (s *UpsertUserAuthenticationBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertUserAuthenticationBadRequest from json.
func (s *UpsertUserAuthenticationBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertUserAuthenticationBadRequest to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertUserAuthenticationBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertUserAuthenticationBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertUserAuthenticationBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertUserAuthenticationInternalServerError as json.
func (s *UpsertUserAuthenticationInternalServerError) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertUserAuthenticationInternalServerError from json.
func (s *UpsertUserAuthenticationInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertUserAuthenticationInternalServerError to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertUserAuthenticationInternalServerError(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertUserAuthenticationInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertUserAuthenticationInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertUserAuthenticationNotFound as json.
func (s *UpsertUserAuthenticationNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertUserAuthenticationNotFound from json.
func (s *UpsertUserAuthenticationNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertUserAuthenticationNotFound to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertUserAuthenticationNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertUserAuthenticationNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertUserAuthenticationNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpsertUserAuthenticationUnauthorized as json.
func (s *UpsertUserAuthenticationUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*ErrorSchema)(s)

	unwrapped.Encode(e)
}

// Decode decodes UpsertUserAuthenticationUnauthorized from json.
func (s *UpsertUserAuthenticationUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpsertUserAuthenticationUnauthorized to nil")
	}
	var unwrapped ErrorSchema
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UpsertUserAuthenticationUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpsertUserAuthenticationUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpsertUserAuthenticationUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *User) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *User) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.CustomID.Set {
			e.FieldStart("customID")
			s.CustomID.Encode(e)
		}
	}
	{
		if s.Groups != nil {
			e.FieldStart("groups")
			e.ArrStart()
			for _, elem := range s.Groups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
}

var jsonFieldsNameOfUser = [7]string{
	0: "id",
	1: "createdAt",
	2: "updatedAt",
	3: "name",
	4: "customID",
	5: "groups",
	6: "tags",
}

// Decode decodes User from json.
func (s *User) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode User to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "customID":
			if err := func() error {
				s.CustomID.Reset()
				if err := s.CustomID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customID\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = make([]Group, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Group
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "tags":
			if err := func() error {
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode User")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUser) {
					name = jsonFieldsNameOfUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *User) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *User) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserAuthentication) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserAuthentication) encodeFields(e *jx.Encoder) {
	{
		if s.BasicAuth.Set {
			e.FieldStart("basicAuth")
			s.BasicAuth.Encode(e)
		}
	}
	{
		if s.Jwt.Set {
			e.FieldStart("jwt")
			s.Jwt.Encode(e)
		}
	}
	{
		if s.HmacAuth.Set {
			e.FieldStart("hmacAuth")
			s.HmacAuth.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserAuthentication = [3]string{
	0: "basicAuth",
	1: "jwt",
	2: "hmacAuth",
}

// Decode decodes UserAuthentication from json.
func (s *UserAuthentication) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserAuthentication to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "basicAuth":
			if err := func() error {
				s.BasicAuth.Reset()
				if err := s.BasicAuth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"basicAuth\"")
			}
		case "jwt":
			if err := func() error {
				s.Jwt.Reset()
				if err := s.Jwt.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jwt\"")
			}
		case "hmacAuth":
			if err := func() error {
				s.HmacAuth.Reset()
				if err := s.HmacAuth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hmacAuth\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserAuthentication")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserAuthentication) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserAuthentication) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserDetail) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.UpdatedAt.Set {
			e.FieldStart("updatedAt")
			s.UpdatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		if s.CustomID.Set {
			e.FieldStart("customID")
			s.CustomID.Encode(e)
		}
	}
	{
		if s.Groups != nil {
			e.FieldStart("groups")
			e.ArrStart()
			for _, elem := range s.Groups {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			s.Tags.Encode(e)
		}
	}
	{
		if s.IpRestrictionConfig.Set {
			e.FieldStart("ipRestrictionConfig")
			s.IpRestrictionConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserDetail = [8]string{
	0: "id",
	1: "createdAt",
	2: "updatedAt",
	3: "name",
	4: "customID",
	5: "groups",
	6: "tags",
	7: "ipRestrictionConfig",
}

// Decode decodes UserDetail from json.
func (s *UserDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserDetail to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			if err := func() error {
				s.UpdatedAt.Reset()
				if err := s.UpdatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "customID":
			if err := func() error {
				s.CustomID.Reset()
				if err := s.CustomID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customID\"")
			}
		case "groups":
			if err := func() error {
				s.Groups = make([]Group, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Group
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Groups = append(s.Groups, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"groups\"")
			}
		case "tags":
			if err := func() error {
				if err := s.Tags.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "ipRestrictionConfig":
			if err := func() error {
				s.IpRestrictionConfig.Reset()
				if err := s.IpRestrictionConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ipRestrictionConfig\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserDetail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserDetail) {
					name = jsonFieldsNameOfUserDetail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserGroupDetail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserGroupDetail) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
	{
		e.FieldStart("name")
		s.Name.Encode(e)
	}
	{
		e.FieldStart("isAssigned")
		e.Bool(s.IsAssigned)
	}
}

var jsonFieldsNameOfUserGroupDetail = [3]string{
	0: "id",
	1: "name",
	2: "isAssigned",
}

// Decode decodes UserGroupDetail from json.
func (s *UserGroupDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserGroupDetail to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "isAssigned":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsAssigned = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isAssigned\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserGroupDetail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserGroupDetail) {
					name = jsonFieldsNameOfUserGroupDetail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserGroupDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserGroupDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
